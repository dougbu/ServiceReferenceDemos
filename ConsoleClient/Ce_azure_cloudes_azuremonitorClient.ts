/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.5.10.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace ConsoleClient {

export class ce_azure_cloudes_azuremonitorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://management.azure.com";
    }

    /**
     * @param subscriptionId The Azure subscription Id.
     * @param resourceGroupName The name of the resource group.
     * @param ruleName The name of the rule.
     * @param api_version Client Api Version.
     * @param parameters The parameters of the rule to create or update.
     * @return Successful request to update an Log Search rule
     */
    createOrUpdate(subscriptionId: string, resourceGroupName: string, ruleName: string, api_version: string, parameters: LogSearchRuleResource): Promise<LogSearchRuleResource> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/microsoft.insights/scheduledQueryRules/{ruleName}?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (resourceGroupName === undefined || resourceGroupName === null)
            throw new Error("The parameter 'resourceGroupName' must be defined.");
        url_ = url_.replace("{resourceGroupName}", encodeURIComponent("" + resourceGroupName)); 
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameters);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdate(_response);
        });
    }

    protected processCreateOrUpdate(response: Response): Promise<LogSearchRuleResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogSearchRuleResource.fromJS(resultData200) : new LogSearchRuleResource();
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? LogSearchRuleResource.fromJS(resultData201) : new LogSearchRuleResource();
            return result201;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param resourceGroupName The name of the resource group.
     * @param ruleName The name of the rule.
     * @param api_version Client Api Version.
     * @param subscriptionId The Azure subscription Id.
     * @return Successful request to get a Log Search rule
     */
    get(resourceGroupName: string, ruleName: string, api_version: string, subscriptionId: string): Promise<LogSearchRuleResource> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/microsoft.insights/scheduledQueryRules/{ruleName}?";
        if (resourceGroupName === undefined || resourceGroupName === null)
            throw new Error("The parameter 'resourceGroupName' must be defined.");
        url_ = url_.replace("{resourceGroupName}", encodeURIComponent("" + resourceGroupName)); 
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName)); 
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LogSearchRuleResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogSearchRuleResource.fromJS(resultData200) : new LogSearchRuleResource();
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param subscriptionId The Azure subscription Id.
     * @param resourceGroupName The name of the resource group.
     * @param ruleName The name of the rule.
     * @param api_version Client Api Version.
     * @param parameters The parameters of the rule to update.
     * @return Successful request to update an Log Search rule
     */
    update(subscriptionId: string, resourceGroupName: string, ruleName: string, api_version: string, parameters: LogSearchRuleResourcePatch): Promise<LogSearchRuleResource> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/microsoft.insights/scheduledQueryRules/{ruleName}?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (resourceGroupName === undefined || resourceGroupName === null)
            throw new Error("The parameter 'resourceGroupName' must be defined.");
        url_ = url_.replace("{resourceGroupName}", encodeURIComponent("" + resourceGroupName)); 
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameters);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<LogSearchRuleResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogSearchRuleResource.fromJS(resultData200) : new LogSearchRuleResource();
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param resourceGroupName The name of the resource group.
     * @param ruleName The name of the rule.
     * @param api_version Client Api Version.
     * @param subscriptionId The Azure subscription Id.
     * @return Successful request to delete a  Log Search rule
     */
    delete(resourceGroupName: string, ruleName: string, api_version: string, subscriptionId: string): Promise<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/microsoft.insights/scheduledQueryRules/{ruleName}?";
        if (resourceGroupName === undefined || resourceGroupName === null)
            throw new Error("The parameter 'resourceGroupName' must be defined.");
        url_ = url_.replace("{resourceGroupName}", encodeURIComponent("" + resourceGroupName)); 
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName)); 
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param api_version Client Api Version.
     * @param filter (optional) The filter to apply on the operation. For more information please see https://msdn.microsoft.com/en-us/library/azure/dn931934.aspx
     * @param subscriptionId The Azure subscription Id.
     * @return Successful request for a list of alert rules
     */
    listBySubscription(api_version: string, filter: string | null | undefined, subscriptionId: string): Promise<LogSearchRuleResourceCollection> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/providers/microsoft.insights/scheduledQueryRules?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListBySubscription(_response);
        });
    }

    protected processListBySubscription(response: Response): Promise<LogSearchRuleResourceCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogSearchRuleResourceCollection.fromJS(resultData200) : new LogSearchRuleResourceCollection();
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param resourceGroupName The name of the resource group.
     * @param api_version Client Api Version.
     * @param filter (optional) The filter to apply on the operation. For more information please see https://msdn.microsoft.com/en-us/library/azure/dn931934.aspx
     * @param subscriptionId The Azure subscription Id.
     * @return Successful request for a list of alert rules
     */
    listByResourceGroup(resourceGroupName: string, api_version: string, filter: string | null | undefined, subscriptionId: string): Promise<LogSearchRuleResourceCollection> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/microsoft.insights/scheduledQueryRules?";
        if (resourceGroupName === undefined || resourceGroupName === null)
            throw new Error("The parameter 'resourceGroupName' must be defined.");
        url_ = url_.replace("{resourceGroupName}", encodeURIComponent("" + resourceGroupName)); 
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (api_version === undefined || api_version === null)
            throw new Error("The parameter 'api_version' must be defined and cannot be null.");
        else
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&"; 
        if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListByResourceGroup(_response);
        });
    }

    protected processListByResourceGroup(response: Response): Promise<LogSearchRuleResourceCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogSearchRuleResourceCollection.fromJS(resultData200) : new LogSearchRuleResourceCollection();
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = resultDatadefault ? ErrorResponse.fromJS(resultDatadefault) : new ErrorResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

/** An azure resource object */
export class Resource implements IResource {
    /** Azure resource Id */
    id?: string | undefined;
    /** Azure resource name */
    name?: string | undefined;
    /** Azure resource type */
    type?: string | undefined;
    /** Resource location */
    location!: string;
    /** Resource tags */
    tags?: Tags | undefined;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.type = data["type"];
            this.location = data["location"];
            this.tags = data["tags"];
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["location"] = this.location;
        data["tags"] = this.tags;
        return data; 
    }
}

/** An azure resource object */
export interface IResource {
    /** Azure resource Id */
    id?: string | undefined;
    /** Azure resource name */
    name?: string | undefined;
    /** Azure resource type */
    type?: string | undefined;
    /** Resource location */
    location: string;
    /** Resource tags */
    tags?: Tags | undefined;
}

/** The Log Search Rule resource. */
export class LogSearchRuleResource extends Resource implements ILogSearchRuleResource {
    /** The rule properties of the resource. */
    properties!: LogSearchRule;

    constructor(data?: ILogSearchRuleResource) {
        super(data);
        if (!data) {
            this.properties = new LogSearchRule();
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.properties = data["properties"] ? LogSearchRule.fromJS(data["properties"]) : new LogSearchRule();
        }
    }

    static fromJS(data: any): LogSearchRuleResource {
        data = typeof data === 'object' ? data : {};
        let result = new LogSearchRuleResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The Log Search Rule resource. */
export interface ILogSearchRuleResource extends IResource {
    /** The rule properties of the resource. */
    properties: LogSearchRule;
}

/** The log search rule resource for patch operations. */
export class LogSearchRuleResourcePatch implements ILogSearchRuleResourcePatch {
    /** Resource tags */
    tags?: Tags2 | undefined;
    /** The log search rule properties of the resource. */
    properties?: LogSearchRulePatch | undefined;

    constructor(data?: ILogSearchRuleResourcePatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tags = data["tags"];
            this.properties = data["properties"] ? LogSearchRulePatch.fromJS(data["properties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LogSearchRuleResourcePatch {
        data = typeof data === 'object' ? data : {};
        let result = new LogSearchRuleResourcePatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tags"] = this.tags;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        return data; 
    }
}

/** The log search rule resource for patch operations. */
export interface ILogSearchRuleResourcePatch {
    /** Resource tags */
    tags?: Tags2 | undefined;
    /** The log search rule properties of the resource. */
    properties?: LogSearchRulePatch | undefined;
}

/** Represents a collection of Log Search rule resources. */
export class LogSearchRuleResourceCollection implements ILogSearchRuleResourceCollection {
    /** The values for the Log Search Rule resources. */
    value?: LogSearchRuleResource[] | undefined;

    constructor(data?: ILogSearchRuleResourceCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["value"] && data["value"].constructor === Array) {
                this.value = [];
                for (let item of data["value"])
                    this.value.push(LogSearchRuleResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogSearchRuleResourceCollection {
        data = typeof data === 'object' ? data : {};
        let result = new LogSearchRuleResourceCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.value && this.value.constructor === Array) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

/** Represents a collection of Log Search rule resources. */
export interface ILogSearchRuleResourceCollection {
    /** The values for the Log Search Rule resources. */
    value?: LogSearchRuleResource[] | undefined;
}

/** Specifies the log search query. */
export class Source implements ISource {
    /** Log search query. Required for action type - AlertingAction */
    query?: string | undefined;
    /** List of  Resource referred into query */
    authorizedResources?: string[] | undefined;
    /** The resource uri over which log search query is to be run. */
    dataSourceId!: string;
    /** Set value to 'ResultCount' . */
    queryType?: QueryType | undefined;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.query = data["query"];
            if (data["authorizedResources"] && data["authorizedResources"].constructor === Array) {
                this.authorizedResources = [];
                for (let item of data["authorizedResources"])
                    this.authorizedResources.push(item);
            }
            this.dataSourceId = data["dataSourceId"];
            this.queryType = data["queryType"];
        }
    }

    static fromJS(data: any): Source {
        data = typeof data === 'object' ? data : {};
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        if (this.authorizedResources && this.authorizedResources.constructor === Array) {
            data["authorizedResources"] = [];
            for (let item of this.authorizedResources)
                data["authorizedResources"].push(item);
        }
        data["dataSourceId"] = this.dataSourceId;
        data["queryType"] = this.queryType;
        return data; 
    }
}

/** Specifies the log search query. */
export interface ISource {
    /** Log search query. Required for action type - AlertingAction */
    query?: string | undefined;
    /** List of  Resource referred into query */
    authorizedResources?: string[] | undefined;
    /** The resource uri over which log search query is to be run. */
    dataSourceId: string;
    /** Set value to 'ResultCount' . */
    queryType?: QueryType | undefined;
}

/** Defines how often to run the search and the time interval. */
export class Schedule implements ISchedule {
    /** frequency (in minutes) at which rule condition should be evaluated. */
    frequencyInMinutes!: number;
    /** Time window for which data needs to be fetched for query (should be greater than or equal to frequencyInMinutes). */
    timeWindowInMinutes!: number;

    constructor(data?: ISchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frequencyInMinutes = data["frequencyInMinutes"];
            this.timeWindowInMinutes = data["timeWindowInMinutes"];
        }
    }

    static fromJS(data: any): Schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frequencyInMinutes"] = this.frequencyInMinutes;
        data["timeWindowInMinutes"] = this.timeWindowInMinutes;
        return data; 
    }
}

/** Defines how often to run the search and the time interval. */
export interface ISchedule {
    /** frequency (in minutes) at which rule condition should be evaluated. */
    frequencyInMinutes: number;
    /** Time window for which data needs to be fetched for query (should be greater than or equal to frequencyInMinutes). */
    timeWindowInMinutes: number;
}

/** The condition that results in the Log Search rule. */
export class TriggerCondition implements ITriggerCondition {
    /** Evaluation operation for rule - 'GreaterThan' or 'LessThan. */
    thresholdOperator!: ConditionalOperator;
    /** Result or count threshold based on which rule should be triggered. */
    threshold!: number;
    /** Trigger condition for metric query rule */
    metricTrigger?: LogMetricTrigger | undefined;

    constructor(data?: ITriggerCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thresholdOperator = data["thresholdOperator"];
            this.threshold = data["threshold"];
            this.metricTrigger = data["metricTrigger"] ? LogMetricTrigger.fromJS(data["metricTrigger"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TriggerCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TriggerCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thresholdOperator"] = this.thresholdOperator;
        data["threshold"] = this.threshold;
        data["metricTrigger"] = this.metricTrigger ? this.metricTrigger.toJSON() : <any>undefined;
        return data; 
    }
}

/** The condition that results in the Log Search rule. */
export interface ITriggerCondition {
    /** Evaluation operation for rule - 'GreaterThan' or 'LessThan. */
    thresholdOperator: ConditionalOperator;
    /** Result or count threshold based on which rule should be triggered. */
    threshold: number;
    /** Trigger condition for metric query rule */
    metricTrigger?: LogMetricTrigger | undefined;
}

/** Azure action group */
export class AzNsActionGroup implements IAzNsActionGroup {
    /** Azure Action Group reference. */
    actionGroup?: string[] | undefined;
    /** Custom subject override for all email ids in Azure action group */
    emailSubject?: string | undefined;
    /** Custom payload to be sent for all webook URI in Azure action group */
    customWebhookPayload?: string | undefined;

    constructor(data?: IAzNsActionGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["actionGroup"] && data["actionGroup"].constructor === Array) {
                this.actionGroup = [];
                for (let item of data["actionGroup"])
                    this.actionGroup.push(item);
            }
            this.emailSubject = data["emailSubject"];
            this.customWebhookPayload = data["customWebhookPayload"];
        }
    }

    static fromJS(data: any): AzNsActionGroup {
        data = typeof data === 'object' ? data : {};
        let result = new AzNsActionGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.actionGroup && this.actionGroup.constructor === Array) {
            data["actionGroup"] = [];
            for (let item of this.actionGroup)
                data["actionGroup"].push(item);
        }
        data["emailSubject"] = this.emailSubject;
        data["customWebhookPayload"] = this.customWebhookPayload;
        return data; 
    }
}

/** Azure action group */
export interface IAzNsActionGroup {
    /** Azure Action Group reference. */
    actionGroup?: string[] | undefined;
    /** Custom subject override for all email ids in Azure action group */
    emailSubject?: string | undefined;
    /** Custom payload to be sent for all webook URI in Azure action group */
    customWebhookPayload?: string | undefined;
}

/** A log metrics trigger descriptor. */
export class LogMetricTrigger implements ILogMetricTrigger {
    /** Evaluation operation for Metric -'GreaterThan' or 'LessThan' or 'Equal'. */
    thresholdOperator?: ConditionalOperator | undefined;
    /** The threshold of the metric trigger. */
    threshold?: number | undefined;
    /** Metric Trigger Type - 'Consecutive' or 'Total' */
    metricTriggerType?: MetricTriggerType | undefined;
    /** Evaluation of metric on a particular column */
    metricColumn?: string | undefined;

    constructor(data?: ILogMetricTrigger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thresholdOperator = data["thresholdOperator"];
            this.threshold = data["threshold"];
            this.metricTriggerType = data["metricTriggerType"];
            this.metricColumn = data["metricColumn"];
        }
    }

    static fromJS(data: any): LogMetricTrigger {
        data = typeof data === 'object' ? data : {};
        let result = new LogMetricTrigger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thresholdOperator"] = this.thresholdOperator;
        data["threshold"] = this.threshold;
        data["metricTriggerType"] = this.metricTriggerType;
        data["metricColumn"] = this.metricColumn;
        return data; 
    }
}

/** A log metrics trigger descriptor. */
export interface ILogMetricTrigger {
    /** Evaluation operation for Metric -'GreaterThan' or 'LessThan' or 'Equal'. */
    thresholdOperator?: ConditionalOperator | undefined;
    /** The threshold of the metric trigger. */
    threshold?: number | undefined;
    /** Metric Trigger Type - 'Consecutive' or 'Total' */
    metricTriggerType?: MetricTriggerType | undefined;
    /** Evaluation of metric on a particular column */
    metricColumn?: string | undefined;
}

/** Result Condition Evaluation criteria. Supported Values - 'GreaterThan' or 'LessThan' or 'Equal'. */
export enum ConditionalOperator {
    GreaterThan = "GreaterThan", 
    LessThan = "LessThan", 
    Equal = "Equal", 
}

/** Metric Trigger Evaluation Type */
export enum MetricTriggerType {
    Consecutive = "Consecutive", 
    Total = "Total", 
}

/** Severity Level of Alert */
export enum AlertSeverity {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
    _4 = "4", 
}

/** Set value to 'ResultAcount' */
export enum QueryType {
    ResultCount = "ResultCount", 
}

/** Log Search Rule Definition */
export class LogSearchRule implements ILogSearchRule {
    /** The description of the Log Search rule. */
    description?: string | undefined;
    /** The flag which indicates whether the Log Search rule is enabled. Value should be true or false */
    enabled?: LogSearchRuleEnabled | undefined;
    /** Last time the rule was updated in IS08601 format. */
    lastUpdatedTime?: Date | undefined;
    /** Provisioning state of the scheduledquery rule */
    provisioningState?: LogSearchRuleProvisioningState | undefined;
    /** Data Source against which rule will Query Data */
    source!: Source;
    /** Schedule (Frequnecy, Time Window) for rule. Required for action type - AlertingAction */
    schedule?: Schedule | undefined;
    /** Action needs to be taken on rule execution. */
    action!: Action;

    constructor(data?: ILogSearchRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.source = new Source();
            this.action = new Action();
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.enabled = data["enabled"];
            this.lastUpdatedTime = data["lastUpdatedTime"] ? new Date(data["lastUpdatedTime"].toString()) : <any>undefined;
            this.provisioningState = data["provisioningState"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : new Source();
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.action = data["action"] ? Action.fromJS(data["action"]) : new Action();
        }
    }

    static fromJS(data: any): LogSearchRule {
        data = typeof data === 'object' ? data : {};
        let result = new LogSearchRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["lastUpdatedTime"] = this.lastUpdatedTime ? this.lastUpdatedTime.toISOString() : <any>undefined;
        data["provisioningState"] = this.provisioningState;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        return data; 
    }
}

/** Log Search Rule Definition */
export interface ILogSearchRule {
    /** The description of the Log Search rule. */
    description?: string | undefined;
    /** The flag which indicates whether the Log Search rule is enabled. Value should be true or false */
    enabled?: LogSearchRuleEnabled | undefined;
    /** Last time the rule was updated in IS08601 format. */
    lastUpdatedTime?: Date | undefined;
    /** Provisioning state of the scheduledquery rule */
    provisioningState?: LogSearchRuleProvisioningState | undefined;
    /** Data Source against which rule will Query Data */
    source: Source;
    /** Schedule (Frequnecy, Time Window) for rule. Required for action type - AlertingAction */
    schedule?: Schedule | undefined;
    /** Action needs to be taken on rule execution. */
    action: Action;
}

/** Log Search Rule Definition for Patching */
export class LogSearchRulePatch implements ILogSearchRulePatch {
    /** The flag which indicates whether the Log Search rule is enabled. Value should be true or false */
    enabled?: LogSearchRulePatchEnabled | undefined;

    constructor(data?: ILogSearchRulePatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enabled = data["enabled"];
        }
    }

    static fromJS(data: any): LogSearchRulePatch {
        data = typeof data === 'object' ? data : {};
        let result = new LogSearchRulePatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        return data; 
    }
}

/** Log Search Rule Definition for Patching */
export interface ILogSearchRulePatch {
    /** The flag which indicates whether the Log Search rule is enabled. Value should be true or false */
    enabled?: LogSearchRulePatchEnabled | undefined;
}

/** Action descriptor. */
export class Action implements IAction {

    protected _discriminator: string;

    constructor(data?: IAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Action";
    }

    init(data?: any) {
    }

    static fromJS(data: any): Action {
        data = typeof data === 'object' ? data : {};
        if (data["odata.type"] === "AlertingAction") {
            let result = new AlertingAction();
            result.init(data);
            return result;
        }
        if (data["odata.type"] === "LogToMetricAction") {
            let result = new LogToMetricAction();
            result.init(data);
            return result;
        }
        let result = new Action();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["odata.type"] = this._discriminator; 
        return data; 
    }
}

/** Action descriptor. */
export interface IAction {
}

/** Specifiy action need to be taken when rule type is Alert */
export class AlertingAction extends Action implements IAlertingAction {
    /** Severity of the alert */
    severity!: AlertSeverity;
    /** Azure action group reference. */
    aznsAction!: AzNsActionGroup;
    /** time (in minutes) for which Alerts should be throttled or suppressed. */
    throttlingInMin?: number | undefined;
    /** The trigger condition that results in the alert rule being. */
    trigger!: TriggerCondition;

    constructor(data?: IAlertingAction) {
        super(data);
        if (!data) {
            this.aznsAction = new AzNsActionGroup();
            this.trigger = new TriggerCondition();
        }
        this._discriminator = "AlertingAction";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.severity = data["severity"];
            this.aznsAction = data["aznsAction"] ? AzNsActionGroup.fromJS(data["aznsAction"]) : new AzNsActionGroup();
            this.throttlingInMin = data["throttlingInMin"];
            this.trigger = data["trigger"] ? TriggerCondition.fromJS(data["trigger"]) : new TriggerCondition();
        }
    }

    static fromJS(data: any): AlertingAction {
        data = typeof data === 'object' ? data : {};
        let result = new AlertingAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["severity"] = this.severity;
        data["aznsAction"] = this.aznsAction ? this.aznsAction.toJSON() : <any>undefined;
        data["throttlingInMin"] = this.throttlingInMin;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Specifiy action need to be taken when rule type is Alert */
export interface IAlertingAction extends IAction {
    /** Severity of the alert */
    severity: AlertSeverity;
    /** Azure action group reference. */
    aznsAction: AzNsActionGroup;
    /** time (in minutes) for which Alerts should be throttled or suppressed. */
    throttlingInMin?: number | undefined;
    /** The trigger condition that results in the alert rule being. */
    trigger: TriggerCondition;
}

/** Specifies the criteria for converting log to metric. */
export class Dimension implements IDimension {
    /** Name of the dimension */
    name!: string;
    /** Operator for dimension values */
    operator!: DimensionOperator;
    /** List of dimension values */
    values!: string[];

    constructor(data?: IDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.operator = data["operator"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
        }
    }

    static fromJS(data: any): Dimension {
        data = typeof data === 'object' ? data : {};
        let result = new Dimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["operator"] = this.operator;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

/** Specifies the criteria for converting log to metric. */
export interface IDimension {
    /** Name of the dimension */
    name: string;
    /** Operator for dimension values */
    operator: DimensionOperator;
    /** List of dimension values */
    values: string[];
}

/** Specifies the criteria for converting log to metric. */
export class Criteria implements ICriteria {
    /** Name of the metric */
    metricName!: string;
    /** List of Dimensions for creating metric */
    dimensions?: Dimension[] | undefined;

    constructor(data?: ICriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.metricName = data["metricName"];
            if (data["dimensions"] && data["dimensions"].constructor === Array) {
                this.dimensions = [];
                for (let item of data["dimensions"])
                    this.dimensions.push(Dimension.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Criteria {
        data = typeof data === 'object' ? data : {};
        let result = new Criteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricName"] = this.metricName;
        if (this.dimensions && this.dimensions.constructor === Array) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        return data; 
    }
}

/** Specifies the criteria for converting log to metric. */
export interface ICriteria {
    /** Name of the metric */
    metricName: string;
    /** List of Dimensions for creating metric */
    dimensions?: Dimension[] | undefined;
}

/** Specifiy action need to be taken when rule type is converting log to metric */
export class LogToMetricAction extends Action implements ILogToMetricAction {
    /** Severity of the alert */
    criteria!: Criteria;

    constructor(data?: ILogToMetricAction) {
        super(data);
        if (!data) {
            this.criteria = new Criteria();
        }
        this._discriminator = "LogToMetricAction";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.criteria = data["criteria"] ? Criteria.fromJS(data["criteria"]) : new Criteria();
        }
    }

    static fromJS(data: any): LogToMetricAction {
        data = typeof data === 'object' ? data : {};
        let result = new LogToMetricAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["criteria"] = this.criteria ? this.criteria.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Specifiy action need to be taken when rule type is converting log to metric */
export interface ILogToMetricAction extends IAction {
    /** Severity of the alert */
    criteria: Criteria;
}

/** Describes the format of Error response. */
export class ErrorResponse implements IErrorResponse {
    /** Error code */
    code?: string | undefined;
    /** Error message indicating why the operation failed. */
    message?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

/** Describes the format of Error response. */
export interface IErrorResponse {
    /** Error code */
    code?: string | undefined;
    /** Error message indicating why the operation failed. */
    message?: string | undefined;
}

export class Tags implements ITags {

    constructor(data?: ITags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Tags {
        data = typeof data === 'object' ? data : {};
        let result = new Tags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ITags {
}

export class Tags2 implements ITags2 {

    constructor(data?: ITags2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Tags2 {
        data = typeof data === 'object' ? data : {};
        let result = new Tags2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ITags2 {
}

export enum LogSearchRuleEnabled {
    True = "true", 
    False = "false", 
}

export enum LogSearchRuleProvisioningState {
    Succeeded = "Succeeded", 
    Deploying = "Deploying", 
    Canceled = "Canceled", 
    Failed = "Failed", 
}

export enum LogSearchRulePatchEnabled {
    True = "true", 
    False = "false", 
}

export enum DimensionOperator {
    Include = "Include", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

}