//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.0.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

namespace ConsoleClient
{
    #pragma warning disable

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.0.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class docs_oracle_com_en_cloud_paas_content_cloud_rest_api_documents_swaggerClient
    {
        private string _baseUrl = "https://";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public docs_oracle_com_en_cloud_paas_content_cloud_rest_api_documents_swaggerClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() =>
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Share Folder or Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder or collection. For sharing the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the share request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ShareFolderResponse> SharesAsync(string folderId, ShareFolderBody payload)
        {
            return SharesAsync(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Share Folder or Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder or collection. For sharing the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the share request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ShareFolderResponse> SharesAsync(string folderId, ShareFolderBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ShareFolderResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ShareFolderResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Unshare Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the unshare folder request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UnshareFolderResponse> Shares2Async(string folderId, UnshareFolderBody payload)
        {
            return Shares2Async(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Unshare Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the unshare folder request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<UnshareFolderResponse> Shares2Async(string folderId, UnshareFolderBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(UnshareFolderResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<UnshareFolderResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(UnshareFolderResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Shared Folder Users</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the get shared folder users request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ShareFolderUsersResponse> ItemsAsync(string folderId, ShareFolderUsersBody payload)
        {
            return ItemsAsync(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Shared Folder Users</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the get shared folder users request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ShareFolderUsersResponse> ItemsAsync(string folderId, ShareFolderUsersBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}/items");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ShareFolderUsersResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderUsersResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ShareFolderUsersResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Shared Folder User Role</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the edit shared folder user role request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ShareFolderResponse> RoleAsync(string folderId, ShareFolderEditRoleBody payload)
        {
            return RoleAsync(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Shared Folder User Role</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code></p>.</param>
        /// <param name="payload">The request body defines details of the edit shared folder user role request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ShareFolderResponse> RoleAsync(string folderId, ShareFolderEditRoleBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}/role");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ShareFolderResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ShareFolderResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Revoke User</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the get shared folder users request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ShareDeleteUserResponse> UserAsync(string folderId, ShareDeleteUserBody payload)
        {
            return UserAsync(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Revoke User</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the get shared folder users request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ShareDeleteUserResponse> UserAsync(string folderId, ShareDeleteUserBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}/user");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ShareDeleteUserResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ShareDeleteUserResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ShareDeleteUserResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Revoke Current User</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ShareDeleteUserResponse> MyuserAsync(string folderId)
        {
            return MyuserAsync(folderId, System.Threading.CancellationToken.None);
        }

        /// <summary>Revoke Current User</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ShareDeleteUserResponse> MyuserAsync(string folderId, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/shares/{folderId}/myuser");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ShareDeleteUserResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ShareDeleteUserResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ShareDeleteUserResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Metadata Collection</summary>
        /// <param name="collectionName"><p>Global collection names must be unique in the instance where the collection is defined and used. User personal collection names must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>, to be user scoped.</p><p><b>Note:</p><p>You cannot change the name of a collection after you create it.</b></p><p>The following restrictions apply to collection and field names:<ul><li>Collection and field names can&#39;t start or end with a space.</li><li>The combined length of the collection and field name can&#39;t exceed 240 characters.</li><li>Collection and file names aren&#39;t case-sensitive; that is, <code>Field Name</code> and <code>field name</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in collection or field names:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in collection or field names:</p></p><ul><li>NUL</li><li>NULL</li><li>xSystem</li><li>xUser</li><li>xAF</li><li>dMetadataUnitID</li><li>dParentMetadataUnitID</li><li>dMetadataInheritLevel</li><li>dAssignedMetaCollection</li><li>dMetaCollection</li><li>dMetaCollections</li><li>dMetadataCollectionID</li><li>dMetadataID</li></ul></p></param>
        /// <param name="payload">The request body defines details of the create metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionCreateResponse> MetadataAsync(string collectionName, CollectionCreateBody payload)
        {
            return MetadataAsync(collectionName, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Metadata Collection</summary>
        /// <param name="collectionName"><p>Global collection names must be unique in the instance where the collection is defined and used. User personal collection names must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>, to be user scoped.</p><p><b>Note:</p><p>You cannot change the name of a collection after you create it.</b></p><p>The following restrictions apply to collection and field names:<ul><li>Collection and field names can&#39;t start or end with a space.</li><li>The combined length of the collection and field name can&#39;t exceed 240 characters.</li><li>Collection and file names aren&#39;t case-sensitive; that is, <code>Field Name</code> and <code>field name</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in collection or field names:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in collection or field names:</p></p><ul><li>NUL</li><li>NULL</li><li>xSystem</li><li>xUser</li><li>xAF</li><li>dMetadataUnitID</li><li>dParentMetadataUnitID</li><li>dMetadataInheritLevel</li><li>dAssignedMetaCollection</li><li>dMetaCollection</li><li>dMetaCollections</li><li>dMetadataCollectionID</li><li>dMetadataID</li></ul></p></param>
        /// <param name="payload">The request body defines details of the create metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionCreateResponse> MetadataAsync(string collectionName, CollectionCreateBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/{collectionName}");
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionCreateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionCreateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p><p>A collection with that name already exists.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionCreateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Status or Fields in a Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <param name="payload">The request body defines the details of edit fields or the enable/disable status in a metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionEditResponse> Metadata2Async(string collectionName, CollectionEditBody payload)
        {
            return Metadata2Async(collectionName, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Status or Fields in a Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <param name="payload">The request body defines the details of edit fields or the enable/disable status in a metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionEditResponse> Metadata2Async(string collectionName, CollectionEditBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/{collectionName}");
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionEditResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionEditResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p><p>A collection with that name does not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionEditResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Metadata Collection Definition</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionGetResponse> Metadata3Async(string collectionName)
        {
            return Metadata3Async(collectionName, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Metadata Collection Definition</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionGetResponse> Metadata3Async(string collectionName, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/{collectionName}");
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionGetResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionGetResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p><p>A collection with that name does not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionGetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionDeleteResponse> Metadata4Async(string collectionName)
        {
            return Metadata4Async(collectionName, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionDeleteResponse> Metadata4Async(string collectionName, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/{collectionName}");
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionDeleteResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDeleteResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p><p>A collection with that name does not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Field Status in a Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <param name="payload">The request body defines the details of the enable/disable status for fields in a metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionEditResponse> FieldAsync(string collectionName, CollectionFieldEditBody payload)
        {
            return FieldAsync(collectionName, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Field Status in a Metadata Collection</summary>
        /// <param name="collectionName">Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <param name="payload">The request body defines the details of the enable/disable status for fields in a metadata collection request.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionEditResponse> FieldAsync(string collectionName, CollectionFieldEditBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/{collectionName}/field");
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionEditResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionEditResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p><p>A collection with that name does not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionEditResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Searchable Metadata Fields</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GetSearchableMetadataResponse> SearchFieldsAsync()
        {
            return SearchFieldsAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>Get Searchable Metadata Fields</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<GetSearchableMetadataResponse> SearchFieldsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/searchFields");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(GetSearchableMetadataResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<GetSearchableMetadataResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GetSearchableMetadataResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Set Searchable Metadata Fields</summary>
        /// <param name="payload">The request body defines the details of setting searchable metadata fields.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SetSearchableMetadataResponse> SearchFields2Async(SetSearchableMetadataRequestBody payload)
        {
            return SearchFields2Async(payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Set Searchable Metadata Fields</summary>
        /// <param name="payload">The request body defines the details of setting searchable metadata fields.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SetSearchableMetadataResponse> SearchFields2Async(SetSearchableMetadataRequestBody payload, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata/searchFields");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SetSearchableMetadataResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SetSearchableMetadataResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Exceeded number of allowed searchable metadata fields.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection or field does not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SetSearchableMetadataResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Available Metadata Collection</summary>
        /// <param name="payload">The request body defines the details of retrieving metadata collections available for the current user. It is not required, and it will retrieve only metadata collections by default. If fields need to be retrieved as well, <code>retrieveFields</code> can be used.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AllAvailableCollectionsResponse> Metadata5Async(AvailableCollectionsRequestBody payload)
        {
            return Metadata5Async(payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Available Metadata Collection</summary>
        /// <param name="payload">The request body defines the details of retrieving metadata collections available for the current user. It is not required, and it will retrieve only metadata collections by default. If fields need to be retrieved as well, <code>retrieveFields</code> can be used.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<AllAvailableCollectionsResponse> Metadata5Async(AvailableCollectionsRequestBody payload, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/metadata");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(AllAvailableCollectionsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AllAvailableCollectionsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AllAvailableCollectionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create a Collection</summary>
        /// <param name="payload"><p>This parameter must include the <code>name</code> parameter, which is the name of the collection. This parameter can optionally include the <code>description</code> parameter, which is a description of the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionCreateResponse> CollectionsAsync(CollectionsCreateBody payload)
        {
            return CollectionsAsync(payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create a Collection</summary>
        /// <param name="payload"><p>This parameter must include the <code>name</code> parameter, which is the name of the collection. This parameter can optionally include the <code>description</code> parameter, which is a description of the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionCreateResponse> CollectionsAsync(CollectionsCreateBody payload, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionCreateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionCreateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionCreateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionDeleteResponse> Collections2Async(string collectionId)
        {
            return Collections2Async(collectionId, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionDeleteResponse> Collections2Async(string collectionId, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionId == null)
                throw new System.ArgumentNullException("collectionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/{collectionId}");
            urlBuilder_.Replace("{collectionId}", System.Uri.EscapeDataString(ConvertToString(collectionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionDeleteResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDeleteResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have rights to the specified collection.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection is in the trash or is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Add an Asset to a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="fileId"><p>Globally unique identifier (GUID) of the asset to be added to the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionAddSingleFileResponse> FilesAsync(string collectionId, string fileId)
        {
            return FilesAsync(collectionId, fileId, System.Threading.CancellationToken.None);
        }

        /// <summary>Add an Asset to a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="fileId"><p>Globally unique identifier (GUID) of the asset to be added to the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionAddSingleFileResponse> FilesAsync(string collectionId, string fileId, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionId == null)
                throw new System.ArgumentNullException("collectionId");

            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/{collectionId}/files/{fileId}");
            urlBuilder_.Replace("{collectionId}", System.Uri.EscapeDataString(ConvertToString(collectionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionAddSingleFileResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionAddSingleFileResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The asset being added is not a digital asset, or request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have rights to the specified collection or asset.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection is in the trash or is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionAddSingleFileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Remove an Asset from a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="fileId"><p>Globally unique identifier (GUID) of the asset to be removed from the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionDeleteSingleFileResponse> Files2Async(string collectionId, string fileId)
        {
            return Files2Async(collectionId, fileId, System.Threading.CancellationToken.None);
        }

        /// <summary>Remove an Asset from a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="fileId"><p>Globally unique identifier (GUID) of the asset to be removed from the collection.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionDeleteSingleFileResponse> Files2Async(string collectionId, string fileId, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionId == null)
                throw new System.ArgumentNullException("collectionId");

            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/{collectionId}/files/{fileId}");
            urlBuilder_.Replace("{collectionId}", System.Uri.EscapeDataString(ConvertToString(collectionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionDeleteSingleFileResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDeleteSingleFileResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have rights to the specified collection.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection is in the trash or is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionDeleteSingleFileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Add a List of Assets to a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="payload">The request body defines details on assets to be added to the collection. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionAddDeleteMultipleFilesResponse> Files3Async(string collectionId, AddMultipleAssetsToCollectionBody payload)
        {
            return Files3Async(collectionId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Add a List of Assets to a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="payload">The request body defines details on assets to be added to the collection. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionAddDeleteMultipleFilesResponse> Files3Async(string collectionId, AddMultipleAssetsToCollectionBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionId == null)
                throw new System.ArgumentNullException("collectionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/{collectionId}/files");
            urlBuilder_.Replace("{collectionId}", System.Uri.EscapeDataString(ConvertToString(collectionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionAddDeleteMultipleFilesResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionAddDeleteMultipleFilesResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The asset being added is not a digital asset, or request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have rights to the specified collection or asset.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection is in the trash or is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionAddDeleteMultipleFilesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Remove a List of Assets from a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="payload">The request body defines details on assets to be removed from the collection. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionAddDeleteMultipleFilesResponse> Files4Async(string collectionId, RemoveMultipleAssetsFromCollectionBody payload)
        {
            return Files4Async(collectionId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Remove a List of Assets from a Collection</summary>
        /// <param name="collectionId"><p>Globally unique identifier (GUID) for the collection.</p></param>
        /// <param name="payload">The request body defines details on assets to be removed from the collection. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionAddDeleteMultipleFilesResponse> Files4Async(string collectionId, RemoveMultipleAssetsFromCollectionBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (collectionId == null)
                throw new System.ArgumentNullException("collectionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/{collectionId}/files");
            urlBuilder_.Replace("{collectionId}", System.Uri.EscapeDataString(ConvertToString(collectionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionAddDeleteMultipleFilesResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionAddDeleteMultipleFilesResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have rights to the specified collection.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Collection is in the trash or is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionAddDeleteMultipleFilesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Retrieve a List of Collections</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollectionListResponse> Items2Async()
        {
            return Items2Async(System.Threading.CancellationToken.None);
        }

        /// <summary>Retrieve a List of Collections</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollectionListResponse> Items2Async(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/collections/items");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollectionListResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionListResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollectionListResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Folder Applink</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines the details of the create applink request. <b>Bold</b> indicates a required value.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplinkResponse> FolderAsync(string folderId, ApplinkBody payload)
        {
            return FolderAsync(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Folder Applink</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines the details of the create applink request. <b>Bold</b> indicates a required value.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ApplinkResponse> FolderAsync(string folderId, ApplinkBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/applinks/folder/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ApplinkResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplinkResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create File Applink</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines the details of the create applink request. <b>Bold</b> indicates a required value.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplinkResponse> FileAsync(string fileId, ApplinkBody payload)
        {
            return FileAsync(fileId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create File Applink</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines the details of the create applink request. <b>Bold</b> indicates a required value.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ApplinkResponse> FileAsync(string fileId, ApplinkBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/applinks/file/{fileId}");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ApplinkResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplinkResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Refresh Applink Token</summary>
        /// <param name="appLinkID"><p>This element uniquely identifies the resource.</p></param>
        /// <param name="accessToken"><p>This element provides access to the resource and expires after 15 minutes.</p></param>
        /// <param name="refreshToken"><p>This element enables you to request a new access token when the current access token expires. The refreshed token expires after 24 hours.</p></param>
        /// <returns>The response body includes the refreshed access token.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplinkTokenResponse> TokenAsync(string appLinkID, string accessToken, string refreshToken)
        {
            return TokenAsync(appLinkID, accessToken, refreshToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Refresh Applink Token</summary>
        /// <param name="appLinkID"><p>This element uniquely identifies the resource.</p></param>
        /// <param name="accessToken"><p>This element provides access to the resource and expires after 15 minutes.</p></param>
        /// <param name="refreshToken"><p>This element enables you to request a new access token when the current access token expires. The refreshed token expires after 24 hours.</p></param>
        /// <returns>The response body includes the refreshed access token.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ApplinkTokenResponse> TokenAsync(string appLinkID, string accessToken, string refreshToken, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/applinks/token");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID == null)
                        throw new System.ArgumentNullException("appLinkID");
                    request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken == null)
                        throw new System.ArgumentNullException("accessToken");
                    request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    if (refreshToken == null)
                        throw new System.ArgumentNullException("refreshToken");
                    request_.Headers.TryAddWithoutValidation("refreshToken", ConvertToString(refreshToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ApplinkTokenResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkTokenResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplinkTokenResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Site from Site</summary>
        /// <param name="siteId"><p>Globally unique identifier (GUID) for the source site.</p></param>
        /// <param name="payload"><p>This parameter includes information such as the <code>name</code> parameter, which is the name of the site. Other parameters supported are <code>description</code> and <code>copyUpdates</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteCreateResponse> SiteAsync(string siteId, SitesCreateBody payload)
        {
            return SiteAsync(siteId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Site from Site</summary>
        /// <param name="siteId"><p>Globally unique identifier (GUID) for the source site.</p></param>
        /// <param name="payload"><p>This parameter includes information such as the <code>name</code> parameter, which is the name of the site. Other parameters supported are <code>description</code> and <code>copyUpdates</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SiteCreateResponse> SiteAsync(string siteId, SitesCreateBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/sites/{siteId}/site");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SiteCreateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SiteCreateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User has insufficient privilege to access Site ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Site ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "409")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Site name already exists.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SiteCreateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get All Versions</summary>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<VersionsResponse> ApiAsync()
        {
            return ApiAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>Get All Versions</summary>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<VersionsResponse> ApiAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(VersionsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<VersionsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(VersionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Specific Version</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<VersionDefinition> Api2Async(string version)
        {
            return Api2Async(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Specific Version</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<VersionDefinition> Api2Async(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(VersionDefinition);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<VersionDefinition>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(VersionDefinition);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CatalogResponse> MetadataCatalogAsync(string version)
        {
            return MetadataCatalogAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CatalogResponse> MetadataCatalogAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CatalogResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CatalogResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CatalogResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Folder metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task FoldersAsync(string version)
        {
            return FoldersAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Folder metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task FoldersAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/folders");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. File metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task Files5Async(string version)
        {
            return Files5Async(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. File metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task Files5Async(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/files");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get User API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. User metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UsersAsync(string version)
        {
            return UsersAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get User API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. User metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task UsersAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/users");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Applink API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Applink metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ApplinksAsync(string version)
        {
            return ApplinksAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Applink API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Applink metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task ApplinksAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/applinks");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Share API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Share metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task Shares3Async(string version)
        {
            return Shares3Async(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Share API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Share metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task Shares3Async(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/shares");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Public Links API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Public link metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PubliclinksAsync(string version)
        {
            return PubliclinksAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Public Links API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Public link metadata includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task PubliclinksAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/publiclinks");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Metadata API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task Metadata6Async(string version)
        {
            return Metadata6Async(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Metadata API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task Metadata6Async(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/metadata");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Configuration API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ConfigurationAsync(string version)
        {
            return ConfigurationAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Configuration API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task ConfigurationAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/configuration");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Collection API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task Collections3Async(string version)
        {
            return Collections3Async(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Collection API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task Collections3Async(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/collections");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Sites API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task SitesAsync(string version)
        {
            return SitesAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Sites API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task SitesAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/sites");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Templates API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task TemplatesAsync(string version)
        {
            return TemplatesAsync(version, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Templates API Catalog</summary>
        /// <param name="version">Version value</param>
        /// <returns>The request was fulfilled. Response includes links to supported services.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task TemplatesAsync(string version, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/{version}/metadata-catalog/templates");
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Users</summary>
        /// <param name="info"><p>Specify a search string used to return matching users. Wildcard characters are not supported.</p></param>
        /// <returns><p>The request was fulfilled.</p><p>If no users are matched, <code>count</code> and <code>errorCode</code> will be "0" and items will not be returned.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UsersResponse> Items3Async(string info)
        {
            return Items3Async(info, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Users</summary>
        /// <param name="info"><p>Specify a search string used to return matching users. Wildcard characters are not supported.</p></param>
        /// <returns><p>The request was fulfilled.</p><p>If no users are matched, <code>count</code> and <code>errorCode</code> will be "0" and items will not be returned.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<UsersResponse> Items3Async(string info, System.Threading.CancellationToken cancellationToken)
        {
            if (info == null)
                throw new System.ArgumentNullException("info");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/users/items?");
            urlBuilder_.Append("info=").Append(System.Uri.EscapeDataString(ConvertToString(info, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(UsersResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<UsersResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Required field \"info\" is not provided.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(UsersResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get User with Email Address</summary>
        /// <param name="email"><p>Specify an email address as a search string used to return a specific matching user. Wildcard characters are not supported.</p></param>
        /// <returns><p>The request was fulfilled.</p><p>If no user is matched, <code>count</code> and <code>errorCode</code> will be "0" and items will not be returned.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UsersResponse> Items4Async(string email)
        {
            return Items4Async(email, System.Threading.CancellationToken.None);
        }

        /// <summary>Get User with Email Address</summary>
        /// <param name="email"><p>Specify an email address as a search string used to return a specific matching user. Wildcard characters are not supported.</p></param>
        /// <returns><p>The request was fulfilled.</p><p>If no user is matched, <code>count</code> and <code>errorCode</code> will be "0" and items will not be returned.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<UsersResponse> Items4Async(string email, System.Threading.CancellationToken cancellationToken)
        {
            if (email == null)
                throw new System.ArgumentNullException("email");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/users/search/items?");
            urlBuilder_.Append("email=").Append(System.Uri.EscapeDataString(ConvertToString(email, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(UsersResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<UsersResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Required field \"email\" is not provided.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(UsersResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Transfer User Content</summary>
        /// <param name="userID"><p>Specify the source <code>userID</code> from where all content will be transferred. User GUID or login can be used.</p></param>
        /// <param name="targetUserID"><p>Specify the destination <code>userID</code> where all content will be transferred. User GUID or login can be used.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserContentTransferResponse> TransferContentAsync(string userID, string targetUserID)
        {
            return TransferContentAsync(userID, targetUserID, System.Threading.CancellationToken.None);
        }

        /// <summary>Transfer User Content</summary>
        /// <param name="userID"><p>Specify the source <code>userID</code> from where all content will be transferred. User GUID or login can be used.</p></param>
        /// <param name="targetUserID"><p>Specify the destination <code>userID</code> where all content will be transferred. User GUID or login can be used.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<UserContentTransferResponse> TransferContentAsync(string userID, string targetUserID, System.Threading.CancellationToken cancellationToken)
        {
            if (userID == null)
                throw new System.ArgumentNullException("userID");

            if (targetUserID == null)
                throw new System.ArgumentNullException("targetUserID");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/users/{userID}/transferContent?");
            urlBuilder_.Replace("{userID}", System.Uri.EscapeDataString(ConvertToString(userID, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append("targetUserID=").Append(System.Uri.EscapeDataString(ConvertToString(targetUserID, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(UserContentTransferResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<UserContentTransferResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Required field is not provided.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Unauthorized access.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Source and/or destination user is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(UserContentTransferResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Information on Multiple Files</summary>
        /// <param name="idList"><p>A comma-separated list of globally unique identifiers (GUIDs) for files. There is a limit of 100 file IDs</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific files.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponseWithConversation> ListsAsync(string idList, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return ListsAsync(idList, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Information on Multiple Files</summary>
        /// <param name="idList"><p>A comma-separated list of globally unique identifiers (GUIDs) for files. There is a limit of 100 file IDs</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific files.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponseWithConversation> ListsAsync(string idList, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (idList == null)
                throw new System.ArgumentNullException("idList");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/lists?");
            urlBuilder_.Append("idList=").Append(System.Uri.EscapeDataString(ConvertToString(idList, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileResponseWithConversation);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileResponseWithConversation>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The <code>idList</code> parameter is missing or has more than 100 file IDs.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The user does not have access to one or more of the file IDs.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>One or more of the file IDs do not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponseWithConversation);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Information</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to query. If the version is not specified, the latest version is used.</p></param>
        /// <param name="includeRenditions"><p>When true, detailed information about existing renditions associated with the file is returned. The default is false.</p></param>
        /// <param name="includeOnlyExistingRenditions"><p>This parameter is ignored unless <code>includeRenditions</code> is true. By default, only information about existing renditions is returned. When false, detailed information about all suported renditions with the file is returned. The <code>exists</code> field will indicate if a rendition has been created. The default is true.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponseWithConversation> Files6Async(string fileId, string version, bool? includeRenditions, bool? includeOnlyExistingRenditions, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Files6Async(fileId, version, includeRenditions, includeOnlyExistingRenditions, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Information</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to query. If the version is not specified, the latest version is used.</p></param>
        /// <param name="includeRenditions"><p>When true, detailed information about existing renditions associated with the file is returned. The default is false.</p></param>
        /// <param name="includeOnlyExistingRenditions"><p>This parameter is ignored unless <code>includeRenditions</code> is true. By default, only information about existing renditions is returned. When false, detailed information about all suported renditions with the file is returned. The <code>exists</code> field will indicate if a rendition has been created. The default is true.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponseWithConversation> Files6Async(string fileId, string version, bool? includeRenditions, bool? includeOnlyExistingRenditions, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeRenditions != null)
            {
                urlBuilder_.Append("includeRenditions=").Append(System.Uri.EscapeDataString(ConvertToString(includeRenditions, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeOnlyExistingRenditions != null)
            {
                urlBuilder_.Append("includeOnlyExistingRenditions=").Append(System.Uri.EscapeDataString(ConvertToString(includeOnlyExistingRenditions, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileResponseWithConversation);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileResponseWithConversation>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponseWithConversation);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the edit file request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> Files7Async(string fileId, FileEditBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Files7Async(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the edit file request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> Files7Async(string fileId, FileEditBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to delete. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileDeleteResponse> Files8Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Files8Async(fileId, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to delete. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileDeleteResponse> Files8Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileDeleteResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileDeleteResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload File</summary>
        /// <param name="jsonInputParameters"><p>You can use this parameter to include the <code>parentID</code> parameter and the <code>duplicateResolution</code> parameter as a JSON payload with the request. <p>Set <code>parentID</code> to the globally unique identifier (GUID) of the folder to upload the file to. <b><p>The <code>parentID</code> parameter must be sent as a part of this JSON payload. This parameter is required.</p></b> For example: </p><code>&#123;<p> &#34;parentID &#34;:&#32;&#32;&#32;&#32;&#34;FB4CD874EF94CD2CC1B60B72T&#34;</p>&#125;</code></p><p>Also, to resolve any conflict with duplicate file names, you can set <code>duplicateResolution</code> to <code>TimeStampSuffix</code>. <p><b>The <code>duplicateResolution</code> parameter can be sent as a part of this JSON payload. This parameter is optional.</b></p> For example:</p> <code>&#123;<p> &#34;parentID &#34;:&#32;&#32;&#32;&#32;&#34;FB4CD874EF94CD2CC1B60B72T&#34;,</p><p> &#34;duplicateResolution  &#34;:&#32;&#32;&#32;&#32;&#34;TimeStampSuffix&#34;</p>&#125;</code></p></param>
        /// <param name="primaryFile">File to upload.</param>
        /// <param name="metadataValues"><p>You can use this parameter to set metadata values to a collection already assigned to any parent folder. The rules are the same as those applied to the set metadata values REST API. Use <code>Content-Type: application/json</code> to describe this information as a JSON object.</p><p>For example:</p><code>&#123;<p> &#34;collection &#34;:&#32;&#32;&#32;&#32;&#34;CollectionA&#34;,</p><p> &#34;fieldA &#34;:&#32;&#32;&#32;&#32;&#34;valueA&#34;,</p><p> &#34;fieldB &#34;:&#32;&#32;&#32;&#32;&#34;valueB&#34;,</p><p> &#34;fieldC &#34;:&#32;&#32;&#32;&#32;&#34;valueC&#34;</p>&#125;</code></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns>Created. The request was fulfilled and the new resource was created.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileUploadResponse> DataAsync(string jsonInputParameters, FileParameter primaryFile, string metadataValues, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return DataAsync(jsonInputParameters, primaryFile, metadataValues, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Upload File</summary>
        /// <param name="jsonInputParameters"><p>You can use this parameter to include the <code>parentID</code> parameter and the <code>duplicateResolution</code> parameter as a JSON payload with the request. <p>Set <code>parentID</code> to the globally unique identifier (GUID) of the folder to upload the file to. <b><p>The <code>parentID</code> parameter must be sent as a part of this JSON payload. This parameter is required.</p></b> For example: </p><code>&#123;<p> &#34;parentID &#34;:&#32;&#32;&#32;&#32;&#34;FB4CD874EF94CD2CC1B60B72T&#34;</p>&#125;</code></p><p>Also, to resolve any conflict with duplicate file names, you can set <code>duplicateResolution</code> to <code>TimeStampSuffix</code>. <p><b>The <code>duplicateResolution</code> parameter can be sent as a part of this JSON payload. This parameter is optional.</b></p> For example:</p> <code>&#123;<p> &#34;parentID &#34;:&#32;&#32;&#32;&#32;&#34;FB4CD874EF94CD2CC1B60B72T&#34;,</p><p> &#34;duplicateResolution  &#34;:&#32;&#32;&#32;&#32;&#34;TimeStampSuffix&#34;</p>&#125;</code></p></param>
        /// <param name="primaryFile">File to upload.</param>
        /// <param name="metadataValues"><p>You can use this parameter to set metadata values to a collection already assigned to any parent folder. The rules are the same as those applied to the set metadata values REST API. Use <code>Content-Type: application/json</code> to describe this information as a JSON object.</p><p>For example:</p><code>&#123;<p> &#34;collection &#34;:&#32;&#32;&#32;&#32;&#34;CollectionA&#34;,</p><p> &#34;fieldA &#34;:&#32;&#32;&#32;&#32;&#34;valueA&#34;,</p><p> &#34;fieldB &#34;:&#32;&#32;&#32;&#32;&#34;valueB&#34;,</p><p> &#34;fieldC &#34;:&#32;&#32;&#32;&#32;&#34;valueC&#34;</p>&#125;</code></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns>Created. The request was fulfilled and the new resource was created.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileUploadResponse> DataAsync(string jsonInputParameters, FileParameter primaryFile, string metadataValues, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/data");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (jsonInputParameters == null)
                        throw new System.ArgumentNullException("jsonInputParameters");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(jsonInputParameters, System.Globalization.CultureInfo.InvariantCulture)), "jsonInputParameters");
                    if (primaryFile == null)
                        throw new System.ArgumentNullException("primaryFile");
                    else
                        content_.Add(new System.Net.Http.StreamContent(primaryFile.Data), "primaryFile", primaryFile.FileName ?? "primaryFile");
                    if (metadataValues != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(metadataValues, System.Globalization.CultureInfo.InvariantCulture)), "metadataValues");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileUploadResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileUploadResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Request parameters are not formatted correctly.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Forbidden if the user does not have write permission.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Folder ID is not found.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileUploadResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload File Version</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="primaryFile">File to upload.</param>
        /// <param name="metadataValues"><p>You can use this parameter to set metadata values to a collection already assigned to any parent folder. The rules are the same as those applied to the set metadata values REST API. Use <code>Content-Type: application/json</code> to describe this information as a JSON object.</p><p>For example:</p><code>&#123;<p> &#34;collection &#34;:&#32;&#32;&#32;&#32;&#34;CollectionA&#34;,</p><p> &#34;fieldA &#34;:&#32;&#32;&#32;&#32;&#34;valueA&#34;,</p><p> &#34;fieldB &#34;:&#32;&#32;&#32;&#32;&#34;valueB&#34;,</p><p> &#34;fieldC &#34;:&#32;&#32;&#32;&#32;&#34;valueC&#34;</p>&#125;</code></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileUploadResponse> Data2Async(string fileId, FileParameter primaryFile, string metadataValues, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Data2Async(fileId, primaryFile, metadataValues, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Upload File Version</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="primaryFile">File to upload.</param>
        /// <param name="metadataValues"><p>You can use this parameter to set metadata values to a collection already assigned to any parent folder. The rules are the same as those applied to the set metadata values REST API. Use <code>Content-Type: application/json</code> to describe this information as a JSON object.</p><p>For example:</p><code>&#123;<p> &#34;collection &#34;:&#32;&#32;&#32;&#32;&#34;CollectionA&#34;,</p><p> &#34;fieldA &#34;:&#32;&#32;&#32;&#32;&#34;valueA&#34;,</p><p> &#34;fieldB &#34;:&#32;&#32;&#32;&#32;&#34;valueB&#34;,</p><p> &#34;fieldC &#34;:&#32;&#32;&#32;&#32;&#34;valueC&#34;</p>&#125;</code></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileUploadResponse> Data2Async(string fileId, FileParameter primaryFile, string metadataValues, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (primaryFile == null)
                        throw new System.ArgumentNullException("primaryFile");
                    else
                        content_.Add(new System.Net.Http.StreamContent(primaryFile.Data), "primaryFile", primaryFile.FileName ?? "primaryFile");
                    if (metadataValues != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(metadataValues, System.Globalization.CultureInfo.InvariantCulture)), "metadataValues");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileUploadResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileUploadResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Request parameters are not formatted correctly.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Forbidden if the user does not have write permission.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("File ID is not found.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileUploadResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Download File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to download. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have at least the downloader role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the downloader role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the file contents.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> Data3Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Data3Async(fileId, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Download File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to download. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have at least the downloader role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the downloader role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the file contents.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> Data3Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_);
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Copy File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines the details of the copy file request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCopyResponse> CopyAsync(string fileId, FileCopyBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return CopyAsync(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Copy File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines the details of the copy file request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCopyResponse> CopyAsync(string fileId, FileCopyBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/copy");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCopyResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCopyResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission for the copied file, or write permission for the destination folder.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCopyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Move File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the move file request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileMoveResponse> MoveAsync(string fileId, FileMoveBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return MoveAsync(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Move File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the move file request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileMoveResponse> MoveAsync(string fileId, FileMoveBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/move");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileMoveResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileMoveResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission for the moved file, or write permission for the destination folder.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileMoveResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Versions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileVersionsResponse> VersionsAsync(string fileId, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return VersionsAsync(fileId, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Versions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileVersionsResponse> VersionsAsync(string fileId, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/versions");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileVersionsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileVersionsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileVersionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Reserve File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileReserveResponse> ReserveAsync(string fileId, string linkID, string dAccessCode)
        {
            return ReserveAsync(fileId, linkID, dAccessCode, System.Threading.CancellationToken.None);
        }

        /// <summary>Reserve File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileReserveResponse> ReserveAsync(string fileId, string linkID, string dAccessCode, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/reserve");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileReserveResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileReserveResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileReserveResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Unreserve File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the unreserve file request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileUnreserveResponse> UnreserveAsync(string fileId, FileUnreserveBody payload, string linkID, string dAccessCode)
        {
            return UnreserveAsync(fileId, payload, linkID, dAccessCode, System.Threading.CancellationToken.None);
        }

        /// <summary>Unreserve File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the unreserve file request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileUnreserveResponse> UnreserveAsync(string fileId, FileUnreserveBody payload, string linkID, string dAccessCode, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/unreserve");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileUnreserveResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileUnreserveResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileUnreserveResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Responsive Thumbnail Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ThumbnailImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return ThumbnailImageAsync(fileId, format, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Responsive Thumbnail Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task ThumbnailImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/thumbnailImage?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (format != null)
            {
                urlBuilder_.Append("format=").Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have read permission to the file ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found, or in rare cases the converted image cannot be returned.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not a jpeg, png, gif or tiff image.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Responsive Small Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task SmallImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return SmallImageAsync(fileId, format, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Responsive Small Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task SmallImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/smallImage?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (format != null)
            {
                urlBuilder_.Append("format=").Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have read permission to the file ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found, or in rare cases the converted image cannot be returned.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not a jpeg, png, gif or tiff image.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Responsive Medium Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be a for jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task MediumImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return MediumImageAsync(fileId, format, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Responsive Medium Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be a for jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task MediumImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/mediumImage?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (format != null)
            {
                urlBuilder_.Append("format=").Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have read permission to the file ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found, or in rare cases the converted image cannot be returned.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not a jpeg, png, gif or tiff image.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Responsive Large Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task LargeImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return LargeImageAsync(fileId, format, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Responsive Large Image</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file. The GUID must be for a jpeg, png, gif or tiff image.</p></param>
        /// <param name="format"><p>Specify the image type to return. The following types are supported:<ul><li><code>jpeg</code> or <code>jpg</code> returns a jpeg image. This is the default value.</li><li><code>webp</code> returns a WebP image.</li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the responsive image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task LargeImageAsync(string fileId, string format, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/largeImage?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (format != null)
            {
                urlBuilder_.Append("format=").Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User does not have read permission to the file ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found, or in rare cases the converted image cannot be returned.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not a jpeg, png, gif or tiff image.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Thumbnail</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the thumbnail image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> ThumbnailAsync(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return ThumbnailAsync(fileId, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Thumbnail</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the thumbnail image.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> ThumbnailAsync(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/thumbnail?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_);
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="rendition"><p>Specify the thumbnail number or page number in the following format.</p><p><ul><li>page&#60;&#35;&#62; <pre>For example: rendition=page3</pre></li><li>thumbnail&#60;&#35;&#62; <pre>For example: rendition=thumbnail3</pre></li><li>uploaded rendition name <pre>For example: rendition=small</pre></li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that system renditions and custom renditions can exist for a specific file version only.</p></param>
        /// <param name="renditionType"><p>Specify the rendition type to retrieve. This parameter needs to be used together with a <code>rendition</code> parameter: thumbnails or page renditions require <code>renditionType=system</code>; custom uploaded renditions require <code>renditionType=uploaded</code>. If <code>renditionType</code> is not specified, the <code>system</code> rendition type will be assumed.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the thumbnail, page rendition image, or custom rendition file uploaded.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> RenditionAsync(string fileId, string rendition, string version, string renditionType, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return RenditionAsync(fileId, rendition, version, renditionType, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="rendition"><p>Specify the thumbnail number or page number in the following format.</p><p><ul><li>page&#60;&#35;&#62; <pre>For example: rendition=page3</pre></li><li>thumbnail&#60;&#35;&#62; <pre>For example: rendition=thumbnail3</pre></li><li>uploaded rendition name <pre>For example: rendition=small</pre></li></ul></p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that system renditions and custom renditions can exist for a specific file version only.</p></param>
        /// <param name="renditionType"><p>Specify the rendition type to retrieve. This parameter needs to be used together with a <code>rendition</code> parameter: thumbnails or page renditions require <code>renditionType=system</code>; custom uploaded renditions require <code>renditionType=uploaded</code>. If <code>renditionType</code> is not specified, the <code>system</code> rendition type will be assumed.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Binary data stream for the thumbnail, page rendition image, or custom rendition file uploaded.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> RenditionAsync(string fileId, string rendition, string version, string renditionType, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            if (rendition == null)
                throw new System.ArgumentNullException("rendition");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/rendition?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append("rendition=").Append(System.Uri.EscapeDataString(ConvertToString(rendition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (renditionType != null)
            {
                urlBuilder_.Append("renditionType=").Append(System.Uri.EscapeDataString(ConvertToString(renditionType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_);
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload Custom Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="jsonInputParameters"><p>You can use this parameter to include the <code>name</code> parameter and the <code>description</code> parameter as a JSON payload with the request. <p>Set <code>name</code> as a unique identifier for this custom rendition within the file&#39;s latest revision scope. <b><p>The <code>name</code> parameter must be sent as a part of this JSON payload. This parameter is required.</p></b> For example: </p><code>&#123;<p> &#34;name &#34;:&#32;&#32;&#32;&#32;&#34;smallCustomRendition&#34;</p>&#125;</code></p><p>The following restrictions apply to <code>name</code>:<ul><li>The length of <code>name</code> can&#39;t exceed 28 characters.</li><li>The <code>name</code> parameter isn&#39;t case-sensitive; that is, <code>smallRendition</code> and <code>smallrendition</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in <code>name</code>:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p><b>The <code>description</code> parameter can be sent as a part of this JSON payload. This parameter is optional.</b></p><p>For example:</p> <code>&#123;<p> &#34;name &#34;:&#32;&#32;&#32;&#32;&#34;smallCustomRendition&#34;,</p><p> &#34;description  &#34;:&#32;&#32;&#32;&#32;&#34;This is a small rendition version for this file&#34;</p>&#125;</code></param>
        /// <param name="file">Custom rendition file to upload.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Created. The request was fulfilled and the new resource was created.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCustomRenditionResponse> Rendition2Async(string fileId, string jsonInputParameters, FileParameter file, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Rendition2Async(fileId, jsonInputParameters, file, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Upload Custom Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="jsonInputParameters"><p>You can use this parameter to include the <code>name</code> parameter and the <code>description</code> parameter as a JSON payload with the request. <p>Set <code>name</code> as a unique identifier for this custom rendition within the file&#39;s latest revision scope. <b><p>The <code>name</code> parameter must be sent as a part of this JSON payload. This parameter is required.</p></b> For example: </p><code>&#123;<p> &#34;name &#34;:&#32;&#32;&#32;&#32;&#34;smallCustomRendition&#34;</p>&#125;</code></p><p>The following restrictions apply to <code>name</code>:<ul><li>The length of <code>name</code> can&#39;t exceed 28 characters.</li><li>The <code>name</code> parameter isn&#39;t case-sensitive; that is, <code>smallRendition</code> and <code>smallrendition</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in <code>name</code>:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p><b>The <code>description</code> parameter can be sent as a part of this JSON payload. This parameter is optional.</b></p><p>For example:</p> <code>&#123;<p> &#34;name &#34;:&#32;&#32;&#32;&#32;&#34;smallCustomRendition&#34;,</p><p> &#34;description  &#34;:&#32;&#32;&#32;&#32;&#34;This is a small rendition version for this file&#34;</p>&#125;</code></param>
        /// <param name="file">Custom rendition file to upload.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>Created. The request was fulfilled and the new resource was created.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCustomRenditionResponse> Rendition2Async(string fileId, string jsonInputParameters, FileParameter file, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/rendition");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (jsonInputParameters == null)
                        throw new System.ArgumentNullException("jsonInputParameters");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(jsonInputParameters, System.Globalization.CultureInfo.InvariantCulture)), "jsonInputParameters");
                    if (file == null)
                        throw new System.ArgumentNullException("file");
                    else
                        content_.Add(new System.Net.Http.StreamContent(file.Data), "file", file.FileName ?? "file");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCustomRenditionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCustomRenditionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>A mandatory parameter is missing or an invalid parameter was provided.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have write permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "409")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>A custom rendition with the given <code>name</code> already exists in the latest version.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCustomRenditionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Custom Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="rendition"><p>Rendition <code>name</code> given to a custom rendition in upload.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that custom renditions can exist for a specific file version only.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task Rendition3Async(string fileId, string rendition, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Rendition3Async(fileId, rendition, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Custom Rendition</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="rendition"><p>Rendition <code>name</code> given to a custom rendition in upload.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that custom renditions can exist for a specific file version only.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task Rendition3Async(string fileId, string rendition, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            if (rendition == null)
                throw new System.ArgumentNullException("rendition");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/rendition?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append("rendition=").Append(System.Uri.EscapeDataString(ConvertToString(rendition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID or rendition is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>List Renditions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="renditionType"><p>Specify the rendition type to retrieve. Use <code>renditionType=system</code> for thumbnail and page renditions; use <code>renditionType=uploaded</code> for custom uploaded renditions.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that system renditions and custom renditions can exist for a specific file version only.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileListCustomRenditionResponse> RenditionsAsync(string fileId, string renditionType, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return RenditionsAsync(fileId, renditionType, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>List Renditions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="renditionType"><p>Specify the rendition type to retrieve. Use <code>renditionType=system</code> for thumbnail and page renditions; use <code>renditionType=uploaded</code> for custom uploaded renditions.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used. It is important to notice that system renditions and custom renditions can exist for a specific file version only.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileListCustomRenditionResponse> RenditionsAsync(string fileId, string renditionType, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/data/renditions?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (renditionType != null)
            {
                urlBuilder_.Append("renditionType=").Append(System.Uri.EscapeDataString(ConvertToString(renditionType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileListCustomRenditionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileListCustomRenditionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileListCustomRenditionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Rendition Page Count</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> PagesAsync(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return PagesAsync(fileId, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Rendition Page Count</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> PagesAsync(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/pages?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_);
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Generate File Renditions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> Pages2Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Pages2Async(fileId, version, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Generate File Renditions</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileResponse> Pages2Async(string fileId, string version, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/pages?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/octet-stream");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_);
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File HTML5 Preview</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="waitForCompletePreview"><p>When true, this call will not return until the HTML5 preview has been created. Using this parameter will delay the return of this call but will ensure the preview is fully available to the system. The default is false.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileHtml5PreviewResponse> PreviewPathAsync(string fileId, string version, string waitForCompletePreview, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return PreviewPathAsync(fileId, version, waitForCompletePreview, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File HTML5 Preview</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="version"><p>Specify the version number of the file to use. If the version is not specified, the latest version is used.</p></param>
        /// <param name="waitForCompletePreview"><p>When true, this call will not return until the HTML5 preview has been created. Using this parameter will delay the return of this call but will ensure the preview is fully available to the system. The default is false.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileHtml5PreviewResponse> PreviewPathAsync(string fileId, string version, string waitForCompletePreview, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/previewPath?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (version != null)
            {
                urlBuilder_.Append("version=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (waitForCompletePreview != null)
            {
                urlBuilder_.Append("waitForCompletePreview=").Append(System.Uri.EscapeDataString(ConvertToString(waitForCompletePreview, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileHtml5PreviewResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileHtml5PreviewResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileHtml5PreviewResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned tags should be retrieved (<code>1</code>) or if all inherited tags should be included as well (<code>0</code>).</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileGetTagsResponse> TagsAsync(string fileId, string directAssigned, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return TagsAsync(fileId, directAssigned, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned tags should be retrieved (<code>1</code>) or if all inherited tags should be included as well (<code>0</code>).</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileGetTagsResponse> TagsAsync(string fileId, string directAssigned, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/tags?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileGetTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileGetTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Set File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the set tag values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileSetTagsResponse> Tags2Async(string fileId, FileSetTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags2Async(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Set File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the set tag values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileSetTagsResponse> Tags2Async(string fileId, FileSetTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/tags");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileSetTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileSetTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileSetTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the edit tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileEditTagsResponse> Tags3Async(string fileId, FileEditTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags3Async(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the edit tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileEditTagsResponse> Tags3Async(string fileId, FileEditTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/tags");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileEditTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileEditTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileEditTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete All File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileDeleteTagsResponse> Tags4Async(string fileId, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags4Async(fileId, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete All File Tags</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileDeleteTagsResponse> Tags4Async(string fileId, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/tags");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileDeleteTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileDeleteTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileDeleteTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Assign a Metadata Collection to a File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="collectionName">Name of the metadata collection to assign. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCollectionResponse> Metadata7Async(string fileId, string collectionName)
        {
            return Metadata7Async(fileId, collectionName, System.Threading.CancellationToken.None);
        }

        /// <summary>Assign a Metadata Collection to a File</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="collectionName">Name of the metadata collection to assign. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</param>
        /// <returns>The request was fulfilled.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCollectionResponse> Metadata7Async(string fileId, string collectionName, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/metadata/{collectionName}");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Request parameters are not formatted correctly.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("Forbidden if the user does not have read permission.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("File ID or collection name is not found.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Assign Values to a File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the assign values to metadata collection request. There are no required attributes.</param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCollectionResponse> Metadata8Async(string fileId, object payload, string appLinkID, string accessToken)
        {
            return Metadata8Async(fileId, payload, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Assign Values to a File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the assign values to metadata collection request. There are no required attributes.</param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCollectionResponse> Metadata8Async(string fileId, object payload, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/metadata");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collection values should be retrieved (<code>1</code>) or if values from all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileGetCollectionResponse> Metadata9Async(string fileId, string directAssigned, string appLinkID, string accessToken)
        {
            return Metadata9Async(fileId, directAssigned, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collection values should be retrieved (<code>1</code>) or if values from all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileGetCollectionResponse> Metadata9Async(string fileId, string directAssigned, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/metadata?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileGetCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileGetCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Values in File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the delete values in the metadata collection request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCollectionResponse> Metadata10Async(string fileId, FileDeleteValuesBody payload, string appLinkID, string accessToken)
        {
            return Metadata10Async(fileId, payload, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Values in File Metadata Collection</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload"><p>The request body defines details of the delete values in the metadata collection request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCollectionResponse> Metadata10Async(string fileId, FileDeleteValuesBody payload, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/metadata");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Assigned Metadata Collections</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collections should be retrieved (<code>1</code>) or if all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileGetAssignedCollectionResponse> MetadataFieldsAsync(string fileId, string directAssigned, string appLinkID, string accessToken)
        {
            return MetadataFieldsAsync(fileId, directAssigned, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Assigned Metadata Collections</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collections should be retrieved (<code>1</code>) or if all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileGetAssignedCollectionResponse> MetadataFieldsAsync(string fileId, string directAssigned, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/metadataFields?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileGetAssignedCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetAssignedCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileGetAssignedCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create File Conversation</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the create file conversation request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileCreateConversationResponse> ConversationAsync(string fileId, FileCreateConversationBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return ConversationAsync(fileId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Create File Conversation</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="payload">The request body defines details of the create file conversation request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileCreateConversationResponse> ConversationAsync(string fileId, FileCreateConversationBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/conversation");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileCreateConversationResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileCreateConversationResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameter is not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileCreateConversationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Accesses</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="limit"><p> Specify the maximum number of accesses to return. Use this parameter to specify how many items to include on a single page of results. The default is 200.</p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (offset=0). </p></param>
        /// <param name="orderBy"><p>The results can be sorted by the fields below. The sort order can be defined as ascending (asc) or descending (desc). The default sort order is ascending. <ul> <li><code>accessedBy</code> sorts by the user who initiated the activity.</li> <li><code>version</code> sorts by version of the item on which activity occurred.</li> <li><code>accessType</code> sorts by the type of the access (for example: preview, download).</li> <li><code>size</code> sorts by the size of the item accesses.</li> <li><code>accessedTime</code> sorts by the time of the access.</li> <li><code>clientIP</code> sorts by IP address of the client on which this activity was initiated.</li> <li><code>errorCode</code> sorts by the status code of the activity.</li> </ul> </p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileAccessesResponse> AccessesAsync(string fileId, string limit, string offset, string orderBy, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return AccessesAsync(fileId, limit, offset, orderBy, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Accesses</summary>
        /// <param name="fileId"><p>Globally unique identifier (GUID) for the file.</p></param>
        /// <param name="limit"><p> Specify the maximum number of accesses to return. Use this parameter to specify how many items to include on a single page of results. The default is 200.</p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (offset=0). </p></param>
        /// <param name="orderBy"><p>The results can be sorted by the fields below. The sort order can be defined as ascending (asc) or descending (desc). The default sort order is ascending. <ul> <li><code>accessedBy</code> sorts by the user who initiated the activity.</li> <li><code>version</code> sorts by version of the item on which activity occurred.</li> <li><code>accessType</code> sorts by the type of the access (for example: preview, download).</li> <li><code>size</code> sorts by the size of the item accesses.</li> <li><code>accessedTime</code> sorts by the time of the access.</li> <li><code>clientIP</code> sorts by IP address of the client on which this activity was initiated.</li> <li><code>errorCode</code> sorts by the status code of the activity.</li> </ul> </p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this file. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access the parent folder or this file. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access the parent folder or this file. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileAccessesResponse> AccessesAsync(string fileId, string limit, string offset, string orderBy, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/files/{fileId}/accesses?");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));
            if (limit != null)
            {
                urlBuilder_.Append("limit=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null)
            {
                urlBuilder_.Append("offset=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null)
            {
                urlBuilder_.Append("orderBy=").Append(System.Uri.EscapeDataString(ConvertToString(orderBy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileAccessesResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileAccessesResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileAccessesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Folder Public Link</summary>
        /// <param name="folderId">Globally unique identifier (GUID) for the folder.</param>
        /// <param name="payload">The request body defines details of the create public link request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PublicLinkCreateResponse> Folder2Async(string folderId, PublicLinkBody payload)
        {
            return Folder2Async(folderId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Folder Public Link</summary>
        /// <param name="folderId">Globally unique identifier (GUID) for the folder.</param>
        /// <param name="payload">The request body defines details of the create public link request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PublicLinkCreateResponse> Folder2Async(string folderId, PublicLinkBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/folder/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(PublicLinkCreateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkCreateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PublicLinkCreateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder Public Link</summary>
        /// <param name="folderId">Globally unique identifier (GUID) for the folder.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderLinksResponse> Folder3Async(string folderId)
        {
            return Folder3Async(folderId, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder Public Link</summary>
        /// <param name="folderId">Globally unique identifier (GUID) for the folder.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderLinksResponse> Folder3Async(string folderId, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/folder/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderLinksResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderLinksResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderLinksResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create File Public Link</summary>
        /// <param name="fileId">Globally unique identifier (GUID) for the file.</param>
        /// <param name="payload">The request body defines details of the create public link request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PublicLinkCreateResponse> File2Async(string fileId, PublicLinkBody payload)
        {
            return File2Async(fileId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create File Public Link</summary>
        /// <param name="fileId">Globally unique identifier (GUID) for the file.</param>
        /// <param name="payload">The request body defines details of the create public link request. <b>Bold</b> indicates a required value.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PublicLinkCreateResponse> File2Async(string fileId, PublicLinkBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/file/{fileId}");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(PublicLinkCreateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkCreateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PublicLinkCreateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get File Public Link</summary>
        /// <param name="fileId">Globally unique identifier (GUID) for the file.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileLinksResponse> File3Async(string fileId)
        {
            return File3Async(fileId, System.Threading.CancellationToken.None);
        }

        /// <summary>Get File Public Link</summary>
        /// <param name="fileId">Globally unique identifier (GUID) for the file.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FileLinksResponse> File3Async(string fileId, System.Threading.CancellationToken cancellationToken)
        {
            if (fileId == null)
                throw new System.ArgumentNullException("fileId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/file/{fileId}");
            urlBuilder_.Replace("{fileId}", System.Uri.EscapeDataString(ConvertToString(fileId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FileLinksResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FileLinksResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>File ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileLinksResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PublicLinkGetResponse> Publiclinks2Async(string linkId)
        {
            return Publiclinks2Async(linkId, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PublicLinkGetResponse> Publiclinks2Async(string linkId, System.Threading.CancellationToken cancellationToken)
        {
            if (linkId == null)
                throw new System.ArgumentNullException("linkId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/{linkId}");
            urlBuilder_.Replace("{linkId}", System.Uri.EscapeDataString(ConvertToString(linkId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(PublicLinkGetResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkGetResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Link ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PublicLinkGetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <param name="payload">The request body defines details of the edit public link request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PublicLinkGetResponse> Publiclinks3Async(string linkId, PublicLinkEditBody payload)
        {
            return Publiclinks3Async(linkId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <param name="payload">The request body defines details of the edit public link request. There are no required attributes.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PublicLinkGetResponse> Publiclinks3Async(string linkId, PublicLinkEditBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (linkId == null)
                throw new System.ArgumentNullException("linkId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/{linkId}");
            urlBuilder_.Replace("{linkId}", System.Uri.EscapeDataString(ConvertToString(linkId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(PublicLinkGetResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkGetResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Link ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PublicLinkGetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PublicLinkDeleteResponse> Publiclinks4Async(string linkId)
        {
            return Publiclinks4Async(linkId, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Public Link</summary>
        /// <param name="linkId">Globally unique identifier (GUID) for the public link.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PublicLinkDeleteResponse> Publiclinks4Async(string linkId, System.Threading.CancellationToken cancellationToken)
        {
            if (linkId == null)
                throw new System.ArgumentNullException("linkId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/publiclinks/{linkId}");
            urlBuilder_.Replace("{linkId}", System.Uri.EscapeDataString(ConvertToString(linkId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(PublicLinkDeleteResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkDeleteResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Link ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PublicLinkDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Site from Template</summary>
        /// <param name="templateId"><p>Globally unique identifier (GUID) for the source template.</p></param>
        /// <param name="payload"><p>This parameter includes information such as the <code>name</code> parameter, which is the name of the site. Other parameters supported are <code>description</code> and <code>copyUpdates</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteCreateFromTemplateResponse> Site2Async(string templateId, SitesCreateFromTemplateBody payload)
        {
            return Site2Async(templateId, payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Site from Template</summary>
        /// <param name="templateId"><p>Globally unique identifier (GUID) for the source template.</p></param>
        /// <param name="payload"><p>This parameter includes information such as the <code>name</code> parameter, which is the name of the site. Other parameters supported are <code>description</code> and <code>copyUpdates</code>.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SiteCreateFromTemplateResponse> Site2Async(string templateId, SitesCreateFromTemplateBody payload, System.Threading.CancellationToken cancellationToken)
        {
            if (templateId == null)
                throw new System.ArgumentNullException("templateId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/templates/{templateId}/site");
            urlBuilder_.Replace("{templateId}", System.Uri.EscapeDataString(ConvertToString(templateId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SiteCreateFromTemplateResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SiteCreateFromTemplateResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>User has insufficient privilege to access Template ID.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Template ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "409")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Site name already exists.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SiteCreateFromTemplateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Collaboration Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CollaborationConfigurationResponse> CollaborationAsync()
        {
            return CollaborationAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>Get Collaboration Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<CollaborationConfigurationResponse> CollaborationAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/config/collaboration");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(CollaborationConfigurationResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<CollaborationConfigurationResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CollaborationConfigurationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get CDN Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ContentDeliveryNetworkResponse> DeliverycdnAsync()
        {
            return DeliverycdnAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>Get CDN Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ContentDeliveryNetworkResponse> DeliverycdnAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/config/sites/deliverycdn");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(ContentDeliveryNetworkResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ContentDeliveryNetworkResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ContentDeliveryNetworkResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Email Notification Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GetNotificationEmailResponse> EmailAsync()
        {
            return EmailAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>Get Email Notification Configuration</summary>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<GetNotificationEmailResponse> EmailAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/config/notification/email");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(GetNotificationEmailResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<GetNotificationEmailResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GetNotificationEmailResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Set Email Notification Configuration</summary>
        /// <param name="payload">The request body defines the details of setting email notification in this service instance.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SetNotificationEmailResponse> Email2Async(SetNotificationEmailRequest payload)
        {
            return Email2Async(payload, System.Threading.CancellationToken.None);
        }

        /// <summary>Set Email Notification Configuration</summary>
        /// <param name="payload">The request body defines the details of setting email notification in this service instance.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SetNotificationEmailResponse> Email2Async(SetNotificationEmailRequest payload, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/config/notification/email");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SetNotificationEmailResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SetNotificationEmailResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Input value is invalid or value requested did not change.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have Admin role.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SetNotificationEmailResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific folder.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderResponseWithConversation> Folders2Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Folders2Async(folderId, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific folder.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderResponseWithConversation> Folders2Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderResponseWithConversation);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderResponseWithConversation>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderResponseWithConversation);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the create folder request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the newly created folder.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderResponse> Folders3Async(string folderId, FolderCreateBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Folders3Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the create folder request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the newly created folder.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderResponse> Folders3Async(string folderId, FolderCreateBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have write permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the edit folder request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderResponse> Folders4Async(string folderId, FolderEditBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Folders4Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the edit folder request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderResponse> Folders4Async(string folderId, FolderEditBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have write permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderDeleteResponse> Folders5Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Folders5Async(folderId, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderDeleteResponse> Folders5Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderDeleteResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDeleteResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Copy Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the copy folder request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderCopyResponse> Copy2Async(string folderId, FolderCopyBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Copy2Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Copy Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the copy folder request. <b>Bold</b> indicates a required value.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderCopyResponse> Copy2Async(string folderId, FolderCopyBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/copy");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderCopyResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCopyResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderCopyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Move Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines details of the move folder request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderMoveResponse> Move2Async(string folderId, FolderMoveBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Move2Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Move Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload"><p>The request body defines details of the move folder request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderMoveResponse> Move2Async(string folderId, FolderMoveBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/move");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderMoveResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderMoveResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderMoveResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Home Folder Contents</summary>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>createdTime</code>, and <code>modifiedTime</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>50</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HomeFolderContents> Items5Async(string orderby, string limit, string offset)
        {
            return Items5Async(orderby, limit, offset, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Home Folder Contents</summary>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>createdTime</code>, and <code>modifiedTime</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>50</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<HomeFolderContents> Items5Async(string orderby, string limit, string offset, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/items?");
            if (orderby != null)
            {
                urlBuilder_.Append("orderby=").Append(System.Uri.EscapeDataString(ConvertToString(orderby, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null)
            {
                urlBuilder_.Append("limit=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null)
            {
                urlBuilder_.Append("offset=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(HomeFolderContents);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<HomeFolderContents>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(HomeFolderContents);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Specific Folder Contents</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="filterName"><p>Filter the results to only those folders and files whose name matches the specified string exactly. If there is no exact match, the call returns an empty list. For example, the following parameter restricts the response to folders (or files) named <code>TestFolder</code>: <pre>filterName=TestFolder</pre></p><p>The filter changes the behavior of the following response parameters:<ul><li>count: The number of items that match the <code>filterName</code> parameter.</li><li>totalResults: The number of items that match the <code>filterName</code> parameter.</li></ul></p></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>createdTime</code>, and <code>modifiedTime</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>50</code>and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SpecificFolderContents> Items6Async(string folderId, string filterName, string orderby, string limit, string offset, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Items6Async(folderId, filterName, orderby, limit, offset, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Specific Folder Contents</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="filterName"><p>Filter the results to only those folders and files whose name matches the specified string exactly. If there is no exact match, the call returns an empty list. For example, the following parameter restricts the response to folders (or files) named <code>TestFolder</code>: <pre>filterName=TestFolder</pre></p><p>The filter changes the behavior of the following response parameters:<ul><li>count: The number of items that match the <code>filterName</code> parameter.</li><li>totalResults: The number of items that match the <code>filterName</code> parameter.</li></ul></p></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>createdTime</code>, and <code>modifiedTime</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>50</code>and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SpecificFolderContents> Items6Async(string folderId, string filterName, string orderby, string limit, string offset, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/items?");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            if (filterName != null)
            {
                urlBuilder_.Append("filterName=").Append(System.Uri.EscapeDataString(ConvertToString(filterName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append("orderby=").Append(System.Uri.EscapeDataString(ConvertToString(orderby, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null)
            {
                urlBuilder_.Append("limit=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null)
            {
                urlBuilder_.Append("offset=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SpecificFolderContents);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SpecificFolderContents>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SpecificFolderContents);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Search Folders or Files</summary>
        /// <param name="fulltext"><p>Search string used to match folders or files. It will search these locations: <code>itemName</code>, <code>contents</code>, <code>extension</code>, <code>ownerName</code>, <code>lastModifiedName</code>, and <code>folderDescription</code>.</p><p>Either <code>fulltext</code> or <code>querytext</code> must be provided in the search API.</p></param>
        /// <param name="querytext"><p>Search string used to search for folders or files using the targets listed below. It can replace <code>fulltext</code>, taking advantage of multiple targets at the same time.</p><p>Either the <code>fulltext</code> or <code>querytext</code> parameter must be provided in the search API.</p> <p>The <code>querytext</code> parameter can target searches against the following string fields or number field. The search query is in the form:</p> <pre>searchField&ltoperation&gtsearchValue</pre> <p>Multiple searches can be combined with &ltAND&gt and &ltOR&GT. Searches are not case-sensitive.</p></br>The following string fields are supported:
        /// <ul> <li>xTags: search for tags</li> <li>fItemType: search by item type, either <code>File</code> to return only file items or <code>Folder</code> to return only folder items.</li> <li>fItemName: search for an item's name.</br>In the response this is the <code>name</code> field.</li> <li>fCreator: search by the ID of the item's creator.<br/>In the response this is the <code>createdBy.id</code> field.</li> <li>fCreatorFullName: search by the full display name of the item's creator. <br/>In the response this is the <code>createdBy.displayName</code> field.</li> <li>fCreatorLoginName: search by the login name of the item's creator. <br/>In the response this is the <code>createdBy.loginName</code> field.</li> <li>fOwner: search by the ID of the item's owner. <br/>In the response this is the <code>ownedBy.id</code> field.</li> <li>fOwnerFullName: search by the full display name of the item's owner.<br/>In the response this is the <code>ownedBy.displayName</code> field.</li> <li>fOwnerLoginName: search by the login name of the item's owner.<br/>In the response this is the <code>ownedBy.loginName</code> field.</li> <li>fLastModifier: search by the ID of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.id</code> field.</li> <li>fLastModifierFullName: search by the full display name of the user to last modify the item.<br/>In the response this is the <code>modifiedBy.displayName</code> field.</li> <li>fLastModifierLoginName: search by the login name of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.loginName</code> field.</li> <li>Searchable metadata fields can also be searched as string search targets, but metadata field values are not returned by the search. When you search by metadata fields, the target is <code>MetadataCollectionName.metadataFieldName</code>. For more information about metadata, see <a href='api-metadata-collection.html'>Metadata Collection REST Endpoints</a></li></ul> <p>The string search targets support the following operations. <ul> <li> &ltMATCHES&gt The text in the querytext parameter must be an exact match to the field being searched.</li> <li>&ltCONTAINS&gt The text in the querytext parameter must be contained by separate "words" the field being searched. Here "words" must be separated by tokens like whitespace and periods.</li> </ul> </p></br>
        ///  The following number field is supported:
        ///  <ul><li>dSize: search by the size in bytes of an item.</li></ul> </p> <p> The number search targets support the following operations.
        ///  <ul>
        ///  <li> Use &lt to search for values less that the search value.</li>
        ///  <li> Use = to search for values equal to the search value.</li>
        ///  <li> Use &gt to search for values less than the search value.</li>
        ///  </ul></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>size</code>, <code>lastModifiedName</code>, and <code>lastModifiedDate</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>20</code> and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchFolderContents> Items7Async(string fulltext, string querytext, string orderby, string limit, string offset)
        {
            return Items7Async(fulltext, querytext, orderby, limit, offset, System.Threading.CancellationToken.None);
        }

        /// <summary>Search Folders or Files</summary>
        /// <param name="fulltext"><p>Search string used to match folders or files. It will search these locations: <code>itemName</code>, <code>contents</code>, <code>extension</code>, <code>ownerName</code>, <code>lastModifiedName</code>, and <code>folderDescription</code>.</p><p>Either <code>fulltext</code> or <code>querytext</code> must be provided in the search API.</p></param>
        /// <param name="querytext"><p>Search string used to search for folders or files using the targets listed below. It can replace <code>fulltext</code>, taking advantage of multiple targets at the same time.</p><p>Either the <code>fulltext</code> or <code>querytext</code> parameter must be provided in the search API.</p> <p>The <code>querytext</code> parameter can target searches against the following string fields or number field. The search query is in the form:</p> <pre>searchField&ltoperation&gtsearchValue</pre> <p>Multiple searches can be combined with &ltAND&gt and &ltOR&GT. Searches are not case-sensitive.</p></br>The following string fields are supported:
        /// <ul> <li>xTags: search for tags</li> <li>fItemType: search by item type, either <code>File</code> to return only file items or <code>Folder</code> to return only folder items.</li> <li>fItemName: search for an item's name.</br>In the response this is the <code>name</code> field.</li> <li>fCreator: search by the ID of the item's creator.<br/>In the response this is the <code>createdBy.id</code> field.</li> <li>fCreatorFullName: search by the full display name of the item's creator. <br/>In the response this is the <code>createdBy.displayName</code> field.</li> <li>fCreatorLoginName: search by the login name of the item's creator. <br/>In the response this is the <code>createdBy.loginName</code> field.</li> <li>fOwner: search by the ID of the item's owner. <br/>In the response this is the <code>ownedBy.id</code> field.</li> <li>fOwnerFullName: search by the full display name of the item's owner.<br/>In the response this is the <code>ownedBy.displayName</code> field.</li> <li>fOwnerLoginName: search by the login name of the item's owner.<br/>In the response this is the <code>ownedBy.loginName</code> field.</li> <li>fLastModifier: search by the ID of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.id</code> field.</li> <li>fLastModifierFullName: search by the full display name of the user to last modify the item.<br/>In the response this is the <code>modifiedBy.displayName</code> field.</li> <li>fLastModifierLoginName: search by the login name of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.loginName</code> field.</li> <li>Searchable metadata fields can also be searched as string search targets, but metadata field values are not returned by the search. When you search by metadata fields, the target is <code>MetadataCollectionName.metadataFieldName</code>. For more information about metadata, see <a href='api-metadata-collection.html'>Metadata Collection REST Endpoints</a></li></ul> <p>The string search targets support the following operations. <ul> <li> &ltMATCHES&gt The text in the querytext parameter must be an exact match to the field being searched.</li> <li>&ltCONTAINS&gt The text in the querytext parameter must be contained by separate "words" the field being searched. Here "words" must be separated by tokens like whitespace and periods.</li> </ul> </p></br>
        ///  The following number field is supported:
        ///  <ul><li>dSize: search by the size in bytes of an item.</li></ul> </p> <p> The number search targets support the following operations.
        ///  <ul>
        ///  <li> Use &lt to search for values less that the search value.</li>
        ///  <li> Use = to search for values equal to the search value.</li>
        ///  <li> Use &gt to search for values less than the search value.</li>
        ///  </ul></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>size</code>, <code>lastModifiedName</code>, and <code>lastModifiedDate</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>20</code> and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SearchFolderContents> Items7Async(string fulltext, string querytext, string orderby, string limit, string offset, System.Threading.CancellationToken cancellationToken)
        {
            if (fulltext == null)
                throw new System.ArgumentNullException("fulltext");

            if (querytext == null)
                throw new System.ArgumentNullException("querytext");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/search/items?");
            urlBuilder_.Append("fulltext=").Append(System.Uri.EscapeDataString(ConvertToString(fulltext, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("querytext=").Append(System.Uri.EscapeDataString(ConvertToString(querytext, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (orderby != null)
            {
                urlBuilder_.Append("orderby=").Append(System.Uri.EscapeDataString(ConvertToString(orderby, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null)
            {
                urlBuilder_.Append("limit=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null)
            {
                urlBuilder_.Append("offset=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SearchFolderContents);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SearchFolderContents>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchFolderContents);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Search Folders or Files Under Specific Folder ID</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="fulltext"><p>Search string used to match folders or files. It will search these locations: <code>itemName</code>, <code>contents</code>, <code>extension</code>, <code>ownerName</code>, <code>lastModifiedName</code>, and <code>folderDescription</code>.</p><p>Either <code>fulltext</code> or <code>querytext</code> must be provided in the search API.</p></param>
        /// <param name="querytext"><p>Search string used to search for folders or files using the targets listed below. It can replace <code>fulltext</code>, taking advantage of multiple targets at the same time.</p><p>Either the <code>fulltext</code> or <code>querytext</code> parameter must be provided in the search API.</p> <p>The <code>querytext</code> parameter can target searches against the following string fields or number field. The search query is in the form:</p> <pre>searchField&ltoperation&gtsearchValue</pre> <p>Multiple searches can be combined with &ltAND&gt and &ltOR&GT. Searches are not case-sensitive.</p></br>The following string fields are supported:
        /// <ul> <li>xTags: search for tags</li> <li>fItemType: search by item type, either <code>File</code> to return only file items or <code>Folder</code> to return only folder items.</li> <li>fItemName: search for an item's name.</br>In the response this is the <code>name</code> field.</li> <li>fCreator: search by the ID of the item's creator.<br/>In the response this is the <code>createdBy.id</code> field.</li> <li>fCreatorFullName: search by the full display name of the item's creator. <br/>In the response this is the <code>createdBy.displayName</code> field.</li> <li>fCreatorLoginName: search by the login name of the item's creator. <br/>In the response this is the <code>createdBy.loginName</code> field.</li> <li>fOwner: search by the ID of the item's owner. <br/>In the response this is the <code>ownedBy.id</code> field.</li> <li>fOwnerFullName: search by the full display name of the item's owner.<br/>In the response this is the <code>ownedBy.displayName</code> field.</li> <li>fOwnerLoginName: search by the login name of the item's owner.<br/>In the response this is the <code>ownedBy.loginName</code> field.</li> <li>fLastModifier: search by the ID of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.id</code> field.</li> <li>fLastModifierFullName: search by the full display name of the user to last modify the item.<br/>In the response this is the <code>modifiedBy.displayName</code> field.</li> <li>fLastModifierLoginName: search by the login name of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.loginName</code> field.</li> <li>Searchable metadata fields can also be searched as string search targets, but metadata field values are not returned by the search. When you search by metadata fields, the target is <code>MetadataCollectionName.metadataFieldName</code>. For more information about metadata, see <a href='api-metadata-collection.html'>Metadata Collection REST Endpoints</a></li></ul> <p>The string search targets support the following operations. <ul> <li> &ltMATCHES&gt The text in the querytext parameter must be an exact match to the field being searched.</li> <li>&ltCONTAINS&gt The text in the querytext parameter must be contained by separate "words" the field being searched. Here "words" must be separated by tokens like whitespace and periods.</li> </ul> </p></br>
        ///  The following number field is supported:
        ///  <ul><li>dSize: search by the size in bytes of an item.</li></ul> </p> <p> The number search targets support the following operations.
        ///  <ul>
        ///  <li> Use &lt to search for values less that the search value.</li>
        ///  <li> Use = to search for values equal to the search value.</li>
        ///  <li> Use &gt to search for values less than the search value.</li>
        ///  </ul></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>size</code>, <code>lastModifiedName</code>, and <code>lastModifiedDate</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>20</code> and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchSpecificFolderContents> Items8Async(string folderId, string fulltext, string querytext, string orderby, string limit, string offset, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Items8Async(folderId, fulltext, querytext, orderby, limit, offset, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Search Folders or Files Under Specific Folder ID</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="fulltext"><p>Search string used to match folders or files. It will search these locations: <code>itemName</code>, <code>contents</code>, <code>extension</code>, <code>ownerName</code>, <code>lastModifiedName</code>, and <code>folderDescription</code>.</p><p>Either <code>fulltext</code> or <code>querytext</code> must be provided in the search API.</p></param>
        /// <param name="querytext"><p>Search string used to search for folders or files using the targets listed below. It can replace <code>fulltext</code>, taking advantage of multiple targets at the same time.</p><p>Either the <code>fulltext</code> or <code>querytext</code> parameter must be provided in the search API.</p> <p>The <code>querytext</code> parameter can target searches against the following string fields or number field. The search query is in the form:</p> <pre>searchField&ltoperation&gtsearchValue</pre> <p>Multiple searches can be combined with &ltAND&gt and &ltOR&GT. Searches are not case-sensitive.</p></br>The following string fields are supported:
        /// <ul> <li>xTags: search for tags</li> <li>fItemType: search by item type, either <code>File</code> to return only file items or <code>Folder</code> to return only folder items.</li> <li>fItemName: search for an item's name.</br>In the response this is the <code>name</code> field.</li> <li>fCreator: search by the ID of the item's creator.<br/>In the response this is the <code>createdBy.id</code> field.</li> <li>fCreatorFullName: search by the full display name of the item's creator. <br/>In the response this is the <code>createdBy.displayName</code> field.</li> <li>fCreatorLoginName: search by the login name of the item's creator. <br/>In the response this is the <code>createdBy.loginName</code> field.</li> <li>fOwner: search by the ID of the item's owner. <br/>In the response this is the <code>ownedBy.id</code> field.</li> <li>fOwnerFullName: search by the full display name of the item's owner.<br/>In the response this is the <code>ownedBy.displayName</code> field.</li> <li>fOwnerLoginName: search by the login name of the item's owner.<br/>In the response this is the <code>ownedBy.loginName</code> field.</li> <li>fLastModifier: search by the ID of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.id</code> field.</li> <li>fLastModifierFullName: search by the full display name of the user to last modify the item.<br/>In the response this is the <code>modifiedBy.displayName</code> field.</li> <li>fLastModifierLoginName: search by the login name of the user to last modify the item. <br/>In the response this is the <code>modifiedBy.loginName</code> field.</li> <li>Searchable metadata fields can also be searched as string search targets, but metadata field values are not returned by the search. When you search by metadata fields, the target is <code>MetadataCollectionName.metadataFieldName</code>. For more information about metadata, see <a href='api-metadata-collection.html'>Metadata Collection REST Endpoints</a></li></ul> <p>The string search targets support the following operations. <ul> <li> &ltMATCHES&gt The text in the querytext parameter must be an exact match to the field being searched.</li> <li>&ltCONTAINS&gt The text in the querytext parameter must be contained by separate "words" the field being searched. Here "words" must be separated by tokens like whitespace and periods.</li> </ul> </p></br>
        ///  The following number field is supported:
        ///  <ul><li>dSize: search by the size in bytes of an item.</li></ul> </p> <p> The number search targets support the following operations.
        ///  <ul>
        ///  <li> Use &lt to search for values less that the search value.</li>
        ///  <li> Use = to search for values equal to the search value.</li>
        ///  <li> Use &gt to search for values less than the search value.</li>
        ///  </ul></param>
        /// <param name="orderby"><p>Order the resulting items using the specified field and sort order. You can use the <code>name</code>, <code>size</code>, <code>lastModifiedName</code>, and <code>lastModifiedDate</code> fields, and a sort order of ascending (<code>asc</code>) or descending (<code>desc</code>). For example, this is the default: <pre>orderby=name:asc</pre></p></param>
        /// <param name="limit"><p>Specify the maximum number of items to return. Use this parameter to specify how many items to include on a single page of results. The default is <code>20</code> and maximum is <code>10000</code>. The following example limits the number of returned items to 10: <pre>limit=10</pre></p></param>
        /// <param name="offset"><p>Specify the point at which to begin the list of items from the complete set of items returned for the action. If you do not specify an offset, the returned items begin with the first item in the item list (<code>offset=0</code>).</p> <p>Use this parameter to specify the starting point for a given page of results from the complete set of returned items. The following example limits the number of items per page to 10 and displays the second page of results (items 11-20):<pre>limit=10&offset=10</pre></p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<SearchSpecificFolderContents> Items8Async(string folderId, string fulltext, string querytext, string orderby, string limit, string offset, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            if (fulltext == null)
                throw new System.ArgumentNullException("fulltext");

            if (querytext == null)
                throw new System.ArgumentNullException("querytext");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/search/items?");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append("fulltext=").Append(System.Uri.EscapeDataString(ConvertToString(fulltext, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("querytext=").Append(System.Uri.EscapeDataString(ConvertToString(querytext, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (orderby != null)
            {
                urlBuilder_.Append("orderby=").Append(System.Uri.EscapeDataString(ConvertToString(orderby, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null)
            {
                urlBuilder_.Append("limit=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null)
            {
                urlBuilder_.Append("offset=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(SearchSpecificFolderContents);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<SearchSpecificFolderContents>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchSpecificFolderContents);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Information on Multiple Folders</summary>
        /// <param name="idList"><p>A comma-separated list of globally unique identifiers (GUIDs) for folders. To reference the user&#39;s home folder,  the value for <code>idList</code> can include <code>self</code>. There is a limit of 100 folder IDs</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific folders.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderListResponseWithConversation> Lists2Async(string idList, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Lists2Async(idList, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Information on Multiple Folders</summary>
        /// <param name="idList"><p>A comma-separated list of globally unique identifiers (GUIDs) for folders. To reference the user&#39;s home folder,  the value for <code>idList</code> can include <code>self</code>. There is a limit of 100 folder IDs</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The response body contains information about the specific folders.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderListResponseWithConversation> Lists2Async(string idList, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (idList == null)
                throw new System.ArgumentNullException("idList");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/lists?");
            urlBuilder_.Append("idList=").Append(System.Uri.EscapeDataString(ConvertToString(idList, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderListResponseWithConversation);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderListResponseWithConversation>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The <code>idList</code> parameter is missing or has more than 100 file IDs.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>The user does not have access to one or more of the folder IDs.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>One or more of the folder IDs do not exist.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderListResponseWithConversation);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned tags should be retrieved (<code>1</code>) or if all inherited tags should be included as well (<code>0</code>).</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderGetTagsResponse> Tags5Async(string folderId, string directAssigned, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags5Async(folderId, directAssigned, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned tags should be retrieved (<code>1</code>) or if all inherited tags should be included as well (<code>0</code>).</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderGetTagsResponse> Tags5Async(string folderId, string directAssigned, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/tags?");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderGetTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderGetTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Set Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the set tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderSetTagsResponse> Tags6Async(string folderId, FolderSetTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags6Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Set Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the set tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderSetTagsResponse> Tags6Async(string folderId, FolderSetTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/tags");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderSetTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderSetTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderSetTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Edit Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the edit tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderEditTagsResponse> Tags7Async(string folderId, FolderEditTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags7Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Edit Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the edit tags values request. There are no required attributes.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderEditTagsResponse> Tags7Async(string folderId, FolderEditTagsBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/tags");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderEditTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderEditTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderEditTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete All Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderDeleteTagsResponse> Tags8Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Tags8Async(folderId, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete All Folder Tags</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderDeleteTagsResponse> Tags8Async(string folderId, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/tags");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderDeleteTagsResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDeleteTagsResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderDeleteTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Assign a Metadata Collection to a Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="collectionName">Name of the metadata collection to assign.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderCollectionResponse> Metadata11Async(string folderId, string collectionName)
        {
            return Metadata11Async(folderId, collectionName, System.Threading.CancellationToken.None);
        }

        /// <summary>Assign a Metadata Collection to a Folder</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="collectionName">Name of the metadata collection to assign.</param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderCollectionResponse> Metadata11Async(string folderId, string collectionName, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            if (collectionName == null)
                throw new System.ArgumentNullException("collectionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/metadata/{collectionName}");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collectionName}", System.Uri.EscapeDataString(ConvertToString(collectionName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID or collection name is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Assign Values to a Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the assign values to metadata collection request. There are no required attributes.</param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderCollectionResponse> Metadata12Async(string folderId, object payload, string appLinkID, string accessToken)
        {
            return Metadata12Async(folderId, payload, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Assign Values to a Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload">The request body defines details of the assign values to metadata collection request. There are no required attributes.</param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderCollectionResponse> Metadata12Async(string folderId, object payload, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/metadata");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collection values should be retrieved (<code>1</code>) or if values from all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderGetCollectionResponse> Metadata13Async(string folderId, string directAssigned, string appLinkID, string accessToken)
        {
            return Metadata13Async(folderId, directAssigned, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just directly assigned collection values should be retrieved (<code>1</code>) or if values from all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderGetCollectionResponse> Metadata13Async(string folderId, string directAssigned, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/metadata?");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderGetCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderGetCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete Values in a Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload"><p>The request body defines details of the delete values in a folder metadata collection request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderCollectionResponse> Metadata14Async(string folderId, FolderDeleteValuesBody payload, string appLinkID, string accessToken)
        {
            return Metadata14Async(folderId, payload, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Delete Values in a Folder Metadata Collection</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="payload"><p>The request body defines details of the delete values in a folder metadata collection request. <b>Bold</b> indicates a required value.</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderCollectionResponse> Metadata14Async(string folderId, FolderDeleteValuesBody payload, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/metadata");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Get Folder Assigned Metadata Collections</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just a directly assigned collection should be retrieved (<code>1</code>) or if all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderGetAssignedCollectionResponse> MetadataFields2Async(string folderId, string directAssigned, string appLinkID, string accessToken)
        {
            return MetadataFields2Async(folderId, directAssigned, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Get Folder Assigned Metadata Collections</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value for <code>folderId</code> is <code>self</code>.</p></param>
        /// <param name="directAssigned"><p>Specify if just a directly assigned collection should be retrieved (<code>1</code>) or if all inherited collections should be included as well (<code>0</code>).</p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderGetAssignedCollectionResponse> MetadataFields2Async(string folderId, string directAssigned, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/metadataFields?");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));
            if (directAssigned != null)
            {
                urlBuilder_.Append("directAssigned=").Append(System.Uri.EscapeDataString(ConvertToString(directAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderGetAssignedCollectionResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetAssignedCollectionResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameters are not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderGetAssignedCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Create Folder Conversation</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the create folder conversation request.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FolderCreateConversationResponse> Conversation2Async(string folderId, FolderCreateConversationBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken)
        {
            return Conversation2Async(folderId, payload, linkID, dAccessCode, appLinkID, accessToken, System.Threading.CancellationToken.None);
        }

        /// <summary>Create Folder Conversation</summary>
        /// <param name="folderId"><p>Globally unique identifier (GUID) for the folder.</p></param>
        /// <param name="payload">The request body defines details of the create folder conversation request.</param>
        /// <param name="linkID"><p>Public link ID of a public link authorizing the current user to access this folder. To work, this public link must have the contributor role granted. It can be used as linkID or LinkID.</p></param>
        /// <param name="dAccessCode"><p>Access code needed to use protected public links. It needs to be sent as part of a Cookie header in the following format: <code>dAccessCode-&#60;linkID&#62;=&#60;passcodeValue&#62;</code></p></param>
        /// <param name="appLinkID"><p>Applink ID authorizing the current user to access this folder. Any time the parameter <code>appLinkID</code> is used, a parameter <code>accessToken</code> must be provided as well. To work, this applink must have at least the contributor role granted. It can be used as appLinkID or AppLinkID.</p></param>
        /// <param name="accessToken"><p>Applink access token authorizing the current user to access this folder. This parameter is mandatory if <code>appLinkID</code> is used. It can be used as accessToken or AccessToken.</p></param>
        /// <returns><p>The request was fulfilled.</p></returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<FolderCreateConversationResponse> Conversation2Async(string folderId, FolderCreateConversationBody payload, string linkID, string dAccessCode, string appLinkID, string accessToken, System.Threading.CancellationToken cancellationToken)
        {
            if (folderId == null)
                throw new System.ArgumentNullException("folderId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/documents/api/1.2/folders/{folderId}/conversation");
            urlBuilder_.Replace("{folderId}", System.Uri.EscapeDataString(ConvertToString(folderId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (linkID != null)
                        request_.Headers.TryAddWithoutValidation("linkID", ConvertToString(linkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (dAccessCode != null)
                        request_.Headers.TryAddWithoutValidation("dAccessCode", ConvertToString(dAccessCode, System.Globalization.CultureInfo.InvariantCulture));
                    if (appLinkID != null)
                        request_.Headers.TryAddWithoutValidation("appLinkID", ConvertToString(appLinkID, System.Globalization.CultureInfo.InvariantCulture));
                    if (accessToken != null)
                        request_.Headers.TryAddWithoutValidation("accessToken", ConvertToString(accessToken, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(payload, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            var result_ = default(FolderCreateConversationResponse);
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCreateConversationResponse>(responseData_, _settings.Value);
                                return result_;
                            }
                            catch (System.Exception exception_)
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Request parameter is not formatted correctly.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Forbidden if the user does not have read permission.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("<p>Folder ID is not found.</p>", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FolderCreateConversationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }



    /// <summary>Share information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareDefinition
    {
        /// <summary>Item type <code>share</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Access level for the shared item.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ShareDefinitionRole? Role { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserWithLoginName User { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareDefinition>(data);
        }

    }

    /// <summary>User information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class User
    {
        /// <summary>Globally unique identifier (GUID) for the user.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>The display name for the user.</summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>Item type <code>user</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static User FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<User>(data);
        }

    }

    /// <summary>User information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class UserWithLoginName
    {
        /// <summary>Globally unique identifier (GUID) for the user.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>The display name for the user.</summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>The login name for the user.</summary>
        [Newtonsoft.Json.JsonProperty("loginName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LoginName { get; set; }

        /// <summary>Item type <code>user</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static UserWithLoginName FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserWithLoginName>(data);
        }

    }

    /// <summary>The request body defines details of the share folder or collection request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareFolderBody
    {
        /// <summary>Globally unique identifier (GUID) for the user.</summary>
        [Newtonsoft.Json.JsonProperty("userID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UserID { get; set; }

        /// <summary><p>Access level for the shared item:</p><p><ul><li><b>viewer:</b> Viewers can look at files, folders, and assets but can&#39;t change things.</li><li><b>downloader:</b> Downloaders can also download files and assets and save them to their own computers.</li><li><b>contributor:</b> Contributors can also modify, update, upload, and delete files or assets.</li><li><b>manager:</b> Managers have all the privileges of the other roles and can add or remove other people as members.</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ShareFolderBodyRole Role { get; set; }

        /// <summary>Optional message sent to the user.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>Apply the share to the specified folder only (<code>1</code>) or to the specified folder and all nested folders (<code>0</code>). By default, this option is not enabled (<code>0</code>).</summary>
        [Newtonsoft.Json.JsonProperty("currentOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CurrentOnly { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareFolderBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderBody>(data);
        }

    }

    /// <summary>The response body includes share information along with user information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareFolderResponse
    {
        /// <summary>Globally unique identifier (GUID) for the folder or collection.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Access level for the shared item.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }

        /// <summary>Item type <code>share</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User User { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareFolderResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderResponse>(data);
        }

    }

    /// <summary>The request body defines details of the unshare folder request. There are no required attributes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class UnshareFolderBody
    {
        /// <summary>Optional message sent to the user.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static UnshareFolderBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UnshareFolderBody>(data);
        }

    }

    /// <summary>The response body includes information about the unshare folder operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class UnshareFolderResponse
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>share</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static UnshareFolderResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UnshareFolderResponse>(data);
        }

    }

    /// <summary>The request body defines details of the get shared folder users request. There are no required attributes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareFolderUsersBody
    {
        /// <summary>Include only the specified folder (<code>true</code>) or include the specified folder along with all nested folders (<code>false</code>). By default, this option is <code>false</code>.</summary>
        [Newtonsoft.Json.JsonProperty("currentOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CurrentOnly { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareFolderUsersBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderUsersBody>(data);
        }

    }

    /// <summary>The response body includes information about the get shared folder users operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareFolderUsersResponse
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>share</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ShareDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareFolderUsersResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderUsersResponse>(data);
        }

    }

    /// <summary>The request body defines details of the edit shared folder user role request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareFolderEditRoleBody
    {
        /// <summary>Globally unique identifier (GUID) for the user.</summary>
        [Newtonsoft.Json.JsonProperty("userID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UserID { get; set; }

        /// <summary><p>Access level for the shared item:</p><p><ul><li><b>viewer:</b> Viewers can look at files and folders but can&#39;t change things.</li><li><b>downloader:</b> Downloaders can also download files and save them to their own computers.</li><li><b>contributor:</b> Contributors can also modify files, update files, upload new files, and delete files.</li><li><b>manager:</b> Managers have all the privileges of the other roles and can add or remove other people as members.</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ShareFolderEditRoleBodyRole Role { get; set; }

        /// <summary>Optional message sent to the user.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareFolderEditRoleBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareFolderEditRoleBody>(data);
        }

    }

    /// <summary>The request body defines details of the revoke user request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareDeleteUserBody
    {
        /// <summary>Globally unique identifier (GUID) for the user.</summary>
        [Newtonsoft.Json.JsonProperty("userID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UserID { get; set; }

        /// <summary>Optional message sent to the user.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareDeleteUserBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareDeleteUserBody>(data);
        }

    }

    /// <summary>The response body includes information about the revoke user operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ShareDeleteUserResponse
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>share</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ShareDeleteUserResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ShareDeleteUserResponse>(data);
        }

    }

    /// <summary><p>Description of fields available to create a metadata collection.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionCreateBody
    {
        /// <summary><p>One or more field names separated by commas. You can add and remove fields after the collection is created. Field names must be unique within the collection. </p><p>The following restrictions apply to collection and field names:<ul><li>Collection and field names can&#39;t start or end with a space.</li><li>The combined length of the collection and field name can&#39;t exceed 240 characters.</li><li>Collection and field names aren&#39;t case-sensitive; that is, <code>Field Name</code> and <code>field name</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in collection or field names:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in collection or field names:</p></p><ul><li>NUL</li><li>NULL</li><li>xSystem</li><li>xUser</li><li>xAF</li><li>dMetadataUnitID</li><li>dParentMetadataUnitID</li><li>dMetadataInheritLevel</li><li>dAssignedMetaCollection</li><li>dMetaCollection</li><li>dMetaCollections</li><li>dMetadataCollectionID</li><li>dMetadataID</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(240)]
        public string Fields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionCreateBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionCreateBody>(data);
        }

    }

    /// <summary><p>Description of fields available in the create metadata collection response.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionCreateResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionCreateResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionCreateResponse>(data);
        }

    }

    /// <summary><p>Description of fields available to edit fields in a metadata collection request. There are no required attributes.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionEditBody
    {
        /// <summary><p>Add one or more field names, separated by commas. You can add and remove fields after the collection is created. Field names must be unique within the collection. </p><p>The following restrictions apply to collection and field names:<ul><li>Collection and field names can&#39;t start or end with a space.</li><li>The combined length of the collection and field name can&#39;t exceed 240 characters.</li><li>Collection and file names aren&#39;t case-sensitive; that is, <code>Field Name</code> and <code>field name</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters in collection or field names:</p><p><table> <tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#91;</td><td>&nbsp;&#93;</td><td>&nbsp;&#123;</td><td>&nbsp;&#125;</td><td>&nbsp;&#61;</td><td>&nbsp;$</td><td>&nbsp;%</td></tr><tr><td>&nbsp;&#39;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#35;</td><td>&nbsp;&#38;</td><td>&nbsp;&#94;</td><td>&nbsp;&#46;</td><td>&nbsp;&#44;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in collection or field names:</p></p><ul><li>NUL</li><li>NULL</li><li>xSystem</li><li>xUser</li><li>xAF</li><li>dMetadataUnitID</li><li>dParentMetadataUnitID</li><li>dMetadataInheritLevel</li><li>dAssignedMetaCollection</li><li>dMetaCollection</li><li>dMetaCollections</li><li>dMetadataCollectionID</li><li>dMetadataID</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("addFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AddFields { get; set; }

        /// <summary>Specify the names of one or more fields to delete, separated by commas.</summary>
        [Newtonsoft.Json.JsonProperty("removeFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoveFields { get; set; }

        /// <summary><p>Enable or disable a metadata collection.</p><p>Possible values are:<ul><li>enable</li><li>disable</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Settings { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionEditBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionEditBody>(data);
        }

    }

    /// <summary>The response body includes information about edit fields in a metadata collection operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionEditResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionEditResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionEditResponse>(data);
        }

    }

    /// <summary>The response body includes information about a metadata collection definition.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionGetResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Metadata collection enable (<code>1</code>) or disable (<code>0</code>) status.</summary>
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IsEnabled { get; set; }

        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>List of field definitions.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CollectionFieldDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionGetResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionGetResponse>(data);
        }

    }

    /// <summary>Metadata collection definition.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionDefinition
    {
        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Collection enable (1) or disable (0) status.</summary>
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IsEnabled { get; set; }

        /// <summary>List of field definitions.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CollectionFieldDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDefinition>(data);
        }

    }

    /// <summary>Metadata fields definition.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionFieldDefinition
    {
        /// <summary>Item type <code>field</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Field name.</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        /// <summary>Field type.</summary>
        [Newtonsoft.Json.JsonProperty("fieldType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldType { get; set; }

        /// <summary>Field enable (1) or disable (0) status.</summary>
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IsEnabled { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionFieldDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionFieldDefinition>(data);
        }

    }

    /// <summary>The response body includes information about deleting a metadata collection.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionDeleteResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionDeleteResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDeleteResponse>(data);
        }

    }

    /// <summary>The request body defines details of the enable/disable fields in a metadata collection request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionFieldEditBody
    {
        /// <summary>Field names, separated by commas.</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fields { get; set; }

        /// <summary><p>Enable or disable metadata fields specified in fields.</p><p>Possible values are:<ul><li>enable</li><li>disable</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Settings { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionFieldEditBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionFieldEditBody>(data);
        }

    }

    /// <summary>The request body defines details of the get all available collections request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class AvailableCollectionsRequestBody
    {
        /// <summary>Retrieve only collections (<code>0</code>) or retrieve collections and respective field definitions (<code>1</code>).</summary>
        [Newtonsoft.Json.JsonProperty("retrieveFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? RetrieveFields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static AvailableCollectionsRequestBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AvailableCollectionsRequestBody>(data);
        }

    }

    /// <summary>The response body includes information about all available collections for the current user.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class AllAvailableCollectionsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataCollections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CollectionDefinition> MetadataCollections { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static AllAvailableCollectionsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AllAvailableCollectionsResponse>(data);
        }

    }

    /// <summary>The response body includes information about all metadata fields available for search purposes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class GetSearchableMetadataResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Number of searchable metadata fields retrieved.</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Number { get; set; }

        /// <summary>Comma-separated list of searchable metadata fields prefixed with their respective collection name.</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fields { get; set; }

        /// <summary>Item type <code>metadata</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static GetSearchableMetadataResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GetSearchableMetadataResponse>(data);
        }

    }

    /// <summary>Description of fields available to set searchable metadata fields.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SetSearchableMetadataRequestBody
    {
        /// <summary>Metadata collection name.</summary>
        [Newtonsoft.Json.JsonProperty("collection", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collection { get; set; }

        /// <summary>Comma-separated list of metadata fields to be set as searchable.</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Fields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SetSearchableMetadataRequestBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SetSearchableMetadataRequestBody>(data);
        }

    }

    /// <summary>The response body confirms if the request was successful.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SetSearchableMetadataResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SetSearchableMetadataResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SetSearchableMetadataResponse>(data);
        }

    }

    /// <summary>The request body defines details on assets to be removed from the collection.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class RemoveMultipleAssetsFromCollectionBody
    {
        /// <summary>(Required) Comma-separated list of globally unique identifiers (GUIDs) of assets to be added to the collection.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>When true, the response includes an items array that includes details on each asset added to the collection.</summary>
        [Newtonsoft.Json.JsonProperty("skipIfNotInCollection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkipIfNotInCollection { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static RemoveMultipleAssetsFromCollectionBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RemoveMultipleAssetsFromCollectionBody>(data);
        }

    }

    /// <summary>The request body defines details on assets to be added to the collection. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class AddMultipleAssetsToCollectionBody
    {
        /// <summary>(Required) Comma-separated list of globally unique identifiers (GUIDs) of assets to be added to the collection.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>(Optional) When true, assets that are already members of the collection are skipped. The response includes an items array that includes details on each asset in the call.</summary>
        [Newtonsoft.Json.JsonProperty("skipDuplicate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkipDuplicate { get; set; }

        /// <summary>(Optional) When true, assets that are not owned by or shared with the user with manager role are skipped. The response includes an items array that includes details on each asset in the call.</summary>
        [Newtonsoft.Json.JsonProperty("skipInaccessible", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkipInaccessible { get; set; }

        /// <summary>(Optional) When true, assets that are not digital assets are skipped. The response includes an items array that includes details on each asset in the call.</summary>
        [Newtonsoft.Json.JsonProperty("skipNotAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkipNotAllowed { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static AddMultipleAssetsToCollectionBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AddMultipleAssetsToCollectionBody>(data);
        }

    }

    /// <summary>The request body defines details of the collection to be created.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionsCreateBody
    {
        /// <summary>Name of the collection to be created.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>Description of the collection to be created.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionsCreateBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionsCreateBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionDeleteSingleFileResponse
    {
        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The collection ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionDeleteSingleFileResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionDeleteSingleFileResponse>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionAddSingleFileResponse
    {
        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The asset ID added to the collection.</summary>
        [Newtonsoft.Json.JsonProperty("itemID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemID { get; set; }

        /// <summary>The collection ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionAddSingleFileResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionAddSingleFileResponse>(data);
        }

    }

    /// <summary><p>The items array is returned only if the optional parameter is used.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionAddDeleteMultipleFilesResponse
    {
        /// <summary>The number of assets acted on by the request.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>The collection ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>A comma-separated list of file IDs that were acted on.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>List of file IDs that were acted on.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ItemsAddedOrRemovedFromCollection> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionAddDeleteMultipleFilesResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionAddDeleteMultipleFilesResponse>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ItemsAddedOrRemovedFromCollection
    {
        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>The collection ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>A message indicating the action was not successful.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>Date the asset was processed.</summary>
        [Newtonsoft.Json.JsonProperty("timeStamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeStamp { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ItemsAddedOrRemovedFromCollection FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ItemsAddedOrRemovedFromCollection>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollectionListResponse
    {
        /// <summary>The number of collections returned.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Indicates if all collections were returned; if all the collections were returned, this is zero (0).</summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HasMore { get; set; }

        /// <summary>The point at which to begin the list of items or page of results from the complete set.</summary>
        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Offset { get; set; }

        /// <summary>Total number of collections owned by the user.</summary>
        [Newtonsoft.Json.JsonProperty("totalOwned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalOwned { get; set; }

        /// <summary>Total number of collections the user can access.</summary>
        [Newtonsoft.Json.JsonProperty("totalResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalResults { get; set; }

        /// <summary>Total number of collections shared with the user.</summary>
        [Newtonsoft.Json.JsonProperty("totalShared", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalShared { get; set; }

        /// <summary>List of collections.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ItemsListedCollection> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollectionListResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollectionListResponse>(data);
        }

    }

    /// <summary>Collection information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ItemsListedCollection
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Collection name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Collection description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>collection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Date the collection was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the collection was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ItemsListedCollection FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ItemsListedCollection>(data);
        }

    }

    /// <summary><p>The request body defines the details of the create applink request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ApplinkBody
    {
        /// <summary>Identifier for the user. This can be a globally unique identifier (GUID) or some other identifier.</summary>
        [Newtonsoft.Json.JsonProperty("assignedUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssignedUser { get; set; }

        /// <summary><p>Access level for the shared item (role keywords must be lowercase):<ul><li>viewer (default)</li><li>downloader</li><li>contributor</li><li>manager</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplinkBodyRole? Role { get; set; }

        /// <summary>Locale used for the applink. Locale can affect how values, such as time, are represented.</summary>
        [Newtonsoft.Json.JsonProperty("userLocale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserLocale { get; set; }

        /// <summary>Time zone used for the applink. The time zone can affect how time values are interpreted.</summary>
        [Newtonsoft.Json.JsonProperty("userTimeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserTimeZone { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ApplinkBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkBody>(data);
        }

    }

    /// <summary>The response body includes information about the applink.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ApplinkResponse
    {
        /// <summary>This element uniquely identifies the resource.</summary>
        [Newtonsoft.Json.JsonProperty("appLinkID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppLinkID { get; set; }

        /// <summary>This element provides access to the resource and expires after 15 minutes. You can refresh the access token any number of times within the time period defined by the refresh token (24 hours).</summary>
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccessToken { get; set; }

        /// <summary>The URL of the resource.</summary>
        [Newtonsoft.Json.JsonProperty("appLinkUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppLinkUrl { get; set; }

        /// <summary>This element enables you to request a new access token when the current access token expires. The refreshed token expires after 24 hours.</summary>
        [Newtonsoft.Json.JsonProperty("refreshToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RefreshToken { get; set; }

        /// <summary>Access level for the shared item.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }

        /// <summary>Globally unique identifier (GUID) for the shared item.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>applink</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ApplinkResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkResponse>(data);
        }

    }

    /// <summary>The response body includes a refreshed access token.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ApplinkTokenResponse
    {
        /// <summary>This element provides access to the resource and expires after 15 minutes. You can refresh the access token any number of times within the time period defined by the refreshed token (24 hours).</summary>
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccessToken { get; set; }

        /// <summary>Item type <code>applink</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ApplinkTokenResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ApplinkTokenResponse>(data);
        }

    }

    /// <summary>The request body defines details of the site to be created.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SitesCreateBody
    {
        /// <summary><p>Name of the site to be created.</p><p>The following restrictions apply to site names:<ul><li>Site name can&#39;t start or end with spaces.</li><li>The length of the name can&#39;t exceed 250 characters.</li><li>Site name isn&#39;t case-sensitive; that is, <code>My Site</code> and <code>MY SITE</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters:</p><p><table><tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td></tr><tr><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#46;</td><td>&nbsp;&#46;&#46;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in site names:</p></p><ul><li>documents</li><li>sites</li><li>authsite</li><li>mobileauthsite</li><li>_sitescloud</li><li>_sitesclouddelivery</li><li>_comps</li><li>_components</li><li>_compdelivery</li><li>_idcservice</li><li>scstemplate_*</li><li>CON</li><li>PRN</li><li>AUX</li><li>CLOCK$</li><li>NUL</li><li>NULL</li><li>COM0</li><li>COM1</li><li>COM2</li><li>COM3</li><li>COM4</li><li>COM5</li><li>COM6</li><li>COM7</li><li>COM8</li><li>COM9</li><li>LPT0</li><li>LPT1</li><li>LPT2</li><li>LPT3</li><li>LPT4</li><li>LPT5</li><li>LPT6</li><li>LPT7</li><li>LPT8</li><li>LPT9</li><li>.DS_STORE</li><li>Users</li><li>_shortcuts</li><li>REALITEMS</li><li>Personal Libraries</li><li>Shared By Me</li><li>Shared With Me</li><li>Favorites</li><li>Trash</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(250)]
        public string Name { get; set; }

        /// <summary>Description of the site to be created.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(2000)]
        public string Description { get; set; }

        /// <summary>Flag indicating whether updates from the source site should be copied (1) or not (0) to the new site.</summary>
        [Newtonsoft.Json.JsonProperty("copyUpdates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CopyUpdates { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SitesCreateBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SitesCreateBody>(data);
        }

    }

    /// <summary><p>The response includes details on the created site.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SiteCreateResponse
    {
        /// <summary>Globally unique identifier (GUID) for the site.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Site name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Site description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>site</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Date the site was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the site was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("pseudoOwnedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User PseudoOwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SiteCreateResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SiteCreateResponse>(data);
        }

    }

    /// <summary>Version information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class VersionDefinition
    {
        /// <summary>Version identifier.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>Indicates whether the version is <code>active</code> or <code>deprecated</code>. The default value is <code>active</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lifecycle { get; set; }

        /// <summary>Indicates whether it is the latest version (<code>true</code>) or not (<code>false</code>).</summary>
        [Newtonsoft.Json.JsonProperty("isLatest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IsLatest { get; set; }

        /// <summary>Indicates when the version will no longer be supported.</summary>
        [Newtonsoft.Json.JsonProperty("terminationDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationDate { get; set; }

        [Newtonsoft.Json.JsonProperty("catalog", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public APILinks Catalog { get; set; }

        /// <summary>List of Links.</summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<APILinks> Links { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static VersionDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<VersionDefinition>(data);
        }

    }

    /// <summary>API links information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class APILinks
    {
        /// <summary>Relationship.</summary>
        [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ref { get; set; }

        /// <summary>Complete URL that uniquely defines the resource.</summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static APILinks FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<APILinks>(data);
        }

    }

    /// <summary>The response body includes information about the API versions operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class VersionsResponse
    {
        /// <summary>List of Versions.</summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VersionDefinition> Links { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static VersionsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<VersionsResponse>(data);
        }

    }

    /// <summary>Catalog information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CatalogDefinition
    {
        /// <summary>Name of the catalog.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>List of catalog links.</summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<APILinks> Links { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CatalogDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CatalogDefinition>(data);
        }

    }

    /// <summary>The response body includes information about the get API catalog operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CatalogResponse
    {
        /// <summary>List of catalogs.</summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CatalogDefinition> Links { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CatalogResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CatalogResponse>(data);
        }

    }

    /// <summary>Folder metadata information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class UsersResponse
    {
        /// <summary>The number of users found.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<User> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static UsersResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UsersResponse>(data);
        }

    }

    /// <summary>User content transfer response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class UserContentTransferResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User SourceUser { get; set; }

        [Newtonsoft.Json.JsonProperty("targetUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User TargetUser { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static UserContentTransferResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserContentTransferResponse>(data);
        }

    }

    /// <summary>File information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileDefinition
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>File name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>File format of the file.</summary>
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MimeType { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Size of the file in bytes.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>File version.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>File creation date.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>File last modified date.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        /// <summary>Time the file was reserved (excluded from response data if the file is not reserved).</summary>
        [Newtonsoft.Json.JsonProperty("reservationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReservationTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("reservedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ReservedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileDefinition>(data);
        }

    }

    /// <summary>File information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileDefinitionWithConversation
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>File name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>File format of the file.</summary>
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MimeType { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Size of the file in bytes.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>File version.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>File creation date.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>File last modified date.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        /// <summary>Time the file was reserved (excluded from response data if the file is not reserved).</summary>
        [Newtonsoft.Json.JsonProperty("reservationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReservationTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("reservedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ReservedBy { get; set; }

        /// <summary>Conversation ID associated with this file or a parent folder.</summary>
        [Newtonsoft.Json.JsonProperty("conversationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationID { get; set; }

        /// <summary>Flag indicating whether the conversation ID is associated with the current file (false) or if the conversation ID is associated with a parent folder (true).</summary>
        [Newtonsoft.Json.JsonProperty("isConversationInherited", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsConversationInherited { get; set; }

        /// <summary>If <code>includeRenditions</code> was true on the request, an array of rendition data is included in the response.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenditionDataDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileDefinitionWithConversation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileDefinitionWithConversation>(data);
        }

    }

    /// <summary>The response body includes information about the file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileResponse : FileDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileResponse>(data);
        }

    }

    /// <summary>The response body includes information about the file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileResponseWithConversation : FileDefinitionWithConversation
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileResponseWithConversation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileResponseWithConversation>(data);
        }

    }

    /// <summary>The response body includes information about the file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileUploadResponse : FileDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorMessage { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileUploadResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileUploadResponse>(data);
        }

    }

    /// <summary><p>The request body defines details of the edit file request. There are no required attributes.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileEditBody
    {
        /// <summary>(Optional) Specify the name to assign to the file.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileEditBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileEditBody>(data);
        }

    }

    /// <summary>The response body includes information about the deleted file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileDeleteResponse
    {
        /// <summary>Globally unique identifier (GUID) of the deleted file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileDeleteResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileDeleteResponse>(data);
        }

    }

    /// <summary><p>The request body defines the details of the copy file request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCopyBody
    {
        /// <summary>(Required) Specify the globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationID { get; set; }

        /// <summary>(Optional) Specify the version number of the file to copy. If the version is not specified, the latest version is used.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>(Optional) Specify the <code>TimeStampSuffix</code> option. The name of the copied file is given a 6-digit suffix from the system timestamp.</summary>
        [Newtonsoft.Json.JsonProperty("duplicateResolution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicateResolution { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCopyBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCopyBody>(data);
        }

    }

    /// <summary>The response body includes information about the copied file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCopyResponse
    {
        /// <summary>Globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationID { get; set; }

        /// <summary>Globally unique identifier (GUID) of the newly created file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCopyResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCopyResponse>(data);
        }

    }

    /// <summary><p>The request body defines the details of the move file request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileMoveBody
    {
        /// <summary>(Required) Specify the globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationID { get; set; }

        /// <summary>(Optional) Specify the <code>TimeStampSuffix</code> option. The name of the moved file is given a 6-digit suffix from the system timestamp.</summary>
        [Newtonsoft.Json.JsonProperty("duplicateResolution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicateResolution { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileMoveBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileMoveBody>(data);
        }

    }

    /// <summary>The response body includes information about the move operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileMoveResponse
    {
        /// <summary>Globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationID { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileMoveResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileMoveResponse>(data);
        }

    }

    /// <summary>The response body includes information about the move operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileVersionsResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent  folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>File name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>List of File Versions.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileVersionsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileVersionsResponse>(data);
        }

    }

    /// <summary>The response body includes information about the reserve operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileReserveResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p>.</summary>
        [Newtonsoft.Json.JsonProperty("reservationDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReservationDate { get; set; }

        [Newtonsoft.Json.JsonProperty("reservedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ReservedBy { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileReserveResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileReserveResponse>(data);
        }

    }

    /// <summary><p>The request body defines details of the unreserve file request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileUnreserveBody
    {
        /// <summary>Globally unique identifier (GUID) of the user who reserved the file.</summary>
        [Newtonsoft.Json.JsonProperty("reservedByUserID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReservedByUserID { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileUnreserveBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileUnreserveBody>(data);
        }

    }

    /// <summary>The response body includes information about the unreserve operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileUnreserveResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileUnreserveResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileUnreserveResponse>(data);
        }

    }

    /// <summary>The response body includes information about the unreserve operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FilePagesResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Number of pages with a rendition image.</summary>
        [Newtonsoft.Json.JsonProperty("pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pages { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FilePagesResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FilePagesResponse>(data);
        }

    }

    /// <summary>The response body includes information about the unreserve operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileGenPagesResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileGenPagesResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileGenPagesResponse>(data);
        }

    }

    /// <summary>The response body includes information about the uploaded rendition.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCustomRenditionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCustomRenditionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCustomRenditionResponse>(data);
        }

    }

    /// <summary>The response body includes information about the list of renditions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileListCustomRenditionResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>List of renditions.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileCustomRenditionDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileListCustomRenditionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileListCustomRenditionResponse>(data);
        }

    }

    /// <summary>Rendition information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCustomRenditionDefinition
    {
        /// <summary>Item type <code>rendition</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Rendition name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Rendition description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Rendition path.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>Rendition original file name.</summary>
        [Newtonsoft.Json.JsonProperty("originalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OriginalName { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCustomRenditionDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCustomRenditionDefinition>(data);
        }

    }

    /// <summary>The response body includes information about the generated HTML5 path.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileHtml5PreviewResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>File version.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>HTML5 preview path.</summary>
        [Newtonsoft.Json.JsonProperty("previewUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreviewUrl { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileHtml5PreviewResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileHtml5PreviewResponse>(data);
        }

    }

    /// <summary>The response body includes information about file tags.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileGetTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Tags associated with this file.</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tags { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileGetTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetTagsResponse>(data);
        }

    }

    /// <summary>The request body defines details of the set tags values request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileSetTagsBody
    {
        /// <summary>Comma-separated list of tags to be set to this file.</summary>
        [Newtonsoft.Json.JsonProperty("setTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SetTags { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileSetTagsBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileSetTagsBody>(data);
        }

    }

    /// <summary>The response body includes information about the file tags set.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileSetTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileSetTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileSetTagsResponse>(data);
        }

    }

    /// <summary>The request body defines details of the edit tags values request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileEditTagsBody
    {
        /// <summary>Comma-separated list of tags to be added to this file.</summary>
        [Newtonsoft.Json.JsonProperty("addTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AddTags { get; set; }

        /// <summary>Comma-separated list of tags to be removed from this file.</summary>
        [Newtonsoft.Json.JsonProperty("removeTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoveTags { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileEditTagsBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileEditTagsBody>(data);
        }

    }

    /// <summary>The response body includes information about file edit tags results.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileEditTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileEditTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileEditTagsResponse>(data);
        }

    }

    /// <summary>The response body includes information about file delete tags results.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileDeleteTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileDeleteTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileDeleteTagsResponse>(data);
        }

    }

    /// <summary>The response body includes information about the assign collection to a file operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCollectionResponse>(data);
        }

    }

    /// <summary>The response body includes information about the assign collection operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileGetCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Collections Metadata { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileGetCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetCollectionResponse>(data);
        }

    }

    /// <summary>Assigned collections.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class Collections : System.Collections.Generic.Dictionary<string, object>
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Collections FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Collections>(data);
        }

    }

    /// <summary>The response body includes information about the get assigned collections operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileGetAssignedCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original file.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CollectionDefinition> MetadataFields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileGetAssignedCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileGetAssignedCollectionResponse>(data);
        }

    }

    /// <summary><p>The request body defines details of the delete values in the metadata collection request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileDeleteValuesBody
    {
        /// <summary>Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("collection", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collection { get; set; }

        /// <summary>One or more field names, separated by commas, whose values you want to delete.</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Fields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileDeleteValuesBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileDeleteValuesBody>(data);
        }

    }

    /// <summary>The request body defines details of the create file conversation request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCreateConversationBody
    {
        /// <summary>Specify the name of the newly created file conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string ConversationName { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCreateConversationBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCreateConversationBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileCreateConversationResponse
    {
        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) of the newly created conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationID { get; set; }

        /// <summary>Conversation name.</summary>
        [Newtonsoft.Json.JsonProperty("conversationName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationName { get; set; }

        /// <summary>Applink for the conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationAppLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationAppLink { get; set; }

        /// <summary>Access token that is valid for this applink for a limited duration.</summary>
        [Newtonsoft.Json.JsonProperty("conversationAppLinkToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationAppLinkToken { get; set; }

        /// <summary>List of inactive users.</summary>
        [Newtonsoft.Json.JsonProperty("listOfRemovedInactiveUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListOfRemovedInactiveUsers { get; set; }

        /// <summary>List of unknown users.</summary>
        [Newtonsoft.Json.JsonProperty("listOfUnknownUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListOfUnknownUsers { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileCreateConversationResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileCreateConversationResponse>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileAccessesResponse
    {
        /// <summary>The number of accesses returned.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Indicates if all accesses were returned; if all the accesses were returned, this is zero (0).</summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HasMore { get; set; }

        /// <summary>The total number of accesses for the item.</summary>
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalCount { get; set; }

        /// <summary>List of File Accesses.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileAccessItemsDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileAccessesResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileAccessesResponse>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileAccessItemsDefinition
    {
        /// <summary>Type of the access (for example#58; preview, download).</summary>
        [Newtonsoft.Json.JsonProperty("accessType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccessType { get; set; }

        /// <summary>Date the item was accessed.</summary>
        [Newtonsoft.Json.JsonProperty("accessedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccessedTime { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file that was accessed.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Version of the file that was accessed.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        [Newtonsoft.Json.JsonProperty("accessedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User AccessedBy { get; set; }

        /// <summary>An error code of zero (0) indicates no errors accessing the file.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The client IP that accessed the file</summary>
        [Newtonsoft.Json.JsonProperty("clientIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientIP { get; set; }

        /// <summary>The referring URL of the access.</summary>
        [Newtonsoft.Json.JsonProperty("refererURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RefererURL { get; set; }

        /// <summary>The size of the accessed file.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileAccessItemsDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileAccessItemsDefinition>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class RenditionDataDefinition
    {
        /// <summary>The name of the rendition.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>The value 'uithumbnail' is used when describing a thumbnail rendition. The value 'imagepreview' is used when describing preview renditions. The value 'responsiveimage' is used when describing responsive images.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>The file format of a rendition.</summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>The status of a rendition. If the rendition has been created the value is 'true' otherwise the value is 'false.'</summary>
        [Newtonsoft.Json.JsonProperty("exists", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Exists { get; set; }

        /// <summary>REST url to access the rendition. For 'uithumbnail' and 'responsiveimage' types the REST url will create the rendition if it does not exist.</summary>
        [Newtonsoft.Json.JsonProperty("link", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link { get; set; }

        /// <summary>The width of a rendition in pixels. The value of '-1' means the height is unknown, a value of '0' means height is not set.</summary>
        [Newtonsoft.Json.JsonProperty("width", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Width { get; set; }

        /// <summary>The height of a rendition in pixels. The value of '-1' means the height is unknown, a value of '0' means height is not set.</summary>
        [Newtonsoft.Json.JsonProperty("height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Height { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static RenditionDataDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RenditionDataDefinition>(data);
        }

    }

    /// <summary>Public link information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkDefinition
    {
        /// <summary>Globally unique identifier (GUID) for the public link.</summary>
        [Newtonsoft.Json.JsonProperty("linkID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkID { get; set; }

        /// <summary>Name of the public link.</summary>
        [Newtonsoft.Json.JsonProperty("linkName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkName { get; set; }

        /// <summary>The group of users who can use the link.</summary>
        [Newtonsoft.Json.JsonProperty("assignedUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AssignedUsers { get; set; }

        /// <summary>Access level for the shared item.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PublicLinkDefinitionRole? Role { get; set; }

        /// <summary>Password for the public link. Use a minimum of 8 characters and a maximum of 50 characters. Passwords are case-sensitive.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        /// <summary>Item type <code>publiclink</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Date and time when the public link was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date and time when the public link expires.</summary>
        [Newtonsoft.Json.JsonProperty("expirationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExpirationTime { get; set; }

        /// <summary>Date and time when the public link was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("lastModifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkDefinition>(data);
        }

    }

    /// <summary>The response body includes information about the newly created public link.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkCreateResponse : PublicLinkDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the folder or file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkCreateResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkCreateResponse>(data);
        }

    }

    /// <summary>The response body includes information about the public link.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkGetResponse : PublicLinkDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkGetResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkGetResponse>(data);
        }

    }

    /// <summary>The request body defines details of the create public link request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkBody
    {
        /// <summary><p>The group of users who can use the link.</p><p><ul><li>Comma-separated list of users (any of user ID, login name, or email address).</li><li>@serviceinstance: Users with an account can access the resource with the privileges specified by the role.</li><li>@everybody: Any user can access the resource with the privileges specified by the role.</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("assignedUsers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssignedUsers { get; set; }

        /// <summary><p>Date and time when the public link expires, in the form <code>yyyy-mm-ddThh:mm:ss</code>. <pre>For example, 2017-01-01T00:00:01.</pre><p></p>If you do not specify an expiration time, the link is valid until you delete the link.</p></summary>
        [Newtonsoft.Json.JsonProperty("expirationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExpirationTime { get; set; }

        /// <summary>Password for the public link. Use a minimum of 8 characters and a maximum of 50 characters. If you do not specify a password, no password is required to use the link.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        /// <summary>Name of the public link. Although the link name is optional, you can have only one unnamed public link for a resource.</summary>
        [Newtonsoft.Json.JsonProperty("linkName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkName { get; set; }

        /// <summary><p>Access level for the shared item.</p><p><b>Note:</b></p><p>Although the default role is viewer, the API user&#39;s preference setting for the default role for public links can override this default with a different value. It is best practice to explicitly set the role with the service call.</p><p>You can grant the specified user any standard role except manager or owner:<ul><li><b>Viewer:</b> Viewers can look at files and folders, but can&#39;t change things.</li><li><b>Downloader:</b> Downloaders can also download files and save them to their own computer.</li><li><b>Contributor:</b> Contributors can also modify files, update files, upload new files, and delete files.</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PublicLinkBodyRole? Role { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkBody>(data);
        }

    }

    /// <summary>The request body defines details of the edit public link request. There are no required attributes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkEditBody
    {
        /// <summary><p>The group of users who can use the link.</p><p><ul><li>Comma-separated list of users (any of user ID, login name, or email address).</li><li>@serviceinstance: Users with an account can access the resource with the privileges specified by the role.</li><li>@everybody: Any user can access the resource with the privileges specified by the role</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("assignedUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AssignedUsers { get; set; }

        /// <summary><p>Date and time when the public link expires, in the form <code>yyyy-mm-ddThh:mm:ss</code>. <pre>For example, 2017-01-01T00:00:01.</pre><p></p>If you do not specify an expiration time, the link is valid until you delete the link.</p></summary>
        [Newtonsoft.Json.JsonProperty("expirationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExpirationTime { get; set; }

        /// <summary>Password for the public link. Use a minimum of 8 characters and a maximum of 50 characters. If you do not specify a password, no password is required to use the link.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        /// <summary><p>Access level for the shared item.</p><p><b>Note:</b></p><p>Although the default role is viewer, the API user&#39;s preference setting for the default role for public links can override this default with a different value. It is best practice to explicitly set the role with the service call.</p><p>You can grant the specified user any standard role except manager or owner:<ul><li><b>Viewer:</b> Viewers can look at files and folders, but can&#39;t change things.</li><li><b>Downloader:</b> Downloaders can also download files and save them to their own computer.</li><li><b>Contributor:</b> Contributors can also modify files, update files, upload new files, and delete files.</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PublicLinkEditBodyRole? Role { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkEditBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkEditBody>(data);
        }

    }

    /// <summary>The response body includes information about public links defined for the specified folder.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderLinksResponse
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>List of public links.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PublicLinkDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderLinksResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderLinksResponse>(data);
        }

    }

    /// <summary>The response body includes information about public links defined for the specified file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileLinksResponse
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>Globally unique identifier (GUID) for the file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>List of public links.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PublicLinkDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileLinksResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileLinksResponse>(data);
        }

    }

    /// <summary>The response body includes information about the deleted public link.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class PublicLinkDeleteResponse
    {
        /// <summary>Globally unique identifier (GUID) for the public link.</summary>
        [Newtonsoft.Json.JsonProperty("linkID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkID { get; set; }

        /// <summary>Item type <code>publiclink</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PublicLinkDeleteResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PublicLinkDeleteResponse>(data);
        }

    }

    /// <summary>The request body defines details of the site to be created.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SitesCreateFromTemplateBody
    {
        /// <summary><p>Name of the site to be created.</p><p>The following restrictions apply to site names:<ul><li>Site name can&#39;t start or end with spaces.</li><li>The length of the name can&#39;t exceed 250 characters.</li><li>Site name isn&#39;t case-sensitive; that is, <code>My Site</code> and <code>MY SITE</code> are considered identical.</li></ul></p><p>Don&#39;t use the following characters:</p><p><table><tr><td>&nbsp;&#47;</td><td>&nbsp;&#92;</td><td>&nbsp;&#60;</td><td>&nbsp;&#62;</td><td>&nbsp;&#42;</td><td>&nbsp;&#34;</td></tr><tr><td>&nbsp;&#63;</td><td>&nbsp;&#58;</td><td>&nbsp;&#46;</td><td>&nbsp;&#46;&#46;</td><td>&nbsp;&#124;</td></tr></table></p><p>The following strings are also not allowed in site names:</p></p><ul><li>documents</li><li>sites</li><li>authsite</li><li>mobileauthsite</li><li>_sitescloud</li><li>_sitesclouddelivery</li><li>_comps</li><li>_components</li><li>_compdelivery</li><li>_idcservice</li><li>scstemplate_*</li><li>CON</li><li>PRN</li><li>AUX</li><li>CLOCK$</li><li>NUL</li><li>NULL</li><li>COM0</li><li>COM1</li><li>COM2</li><li>COM3</li><li>COM4</li><li>COM5</li><li>COM6</li><li>COM7</li><li>COM8</li><li>COM9</li><li>LPT0</li><li>LPT1</li><li>LPT2</li><li>LPT3</li><li>LPT4</li><li>LPT5</li><li>LPT6</li><li>LPT7</li><li>LPT8</li><li>LPT9</li><li>.DS_STORE</li><li>Users</li><li>_shortcuts</li><li>REALITEMS</li><li>Personal Libraries</li><li>Shared By Me</li><li>Shared With Me</li><li>Favorites</li><li>Trash</li></ul></p></summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>Description of the site to be created.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Flag indicating whether updates from the source site should be copied (1) or not (0) to the new site.</summary>
        [Newtonsoft.Json.JsonProperty("copyUpdates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CopyUpdates { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SitesCreateFromTemplateBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SitesCreateFromTemplateBody>(data);
        }

    }

    /// <summary><p>The response includes details on the created site.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SiteCreateFromTemplateResponse
    {
        /// <summary>Globally unique identifier (GUID) for the site.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Site name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Site description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>site</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Date the site was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the site was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("pseudoOwnedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User PseudoOwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SiteCreateFromTemplateResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SiteCreateFromTemplateResponse>(data);
        }

    }

    /// <summary>The response body includes information about Collaboration configurations.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class CollaborationConfigurationResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Collaboration cList URL.</summary>
        [Newtonsoft.Json.JsonProperty("cListURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CListURL { get; set; }

        /// <summary>Collaboration client URL.</summary>
        [Newtonsoft.Json.JsonProperty("clientURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientURL { get; set; }

        /// <summary>Collaboration OAuth cList URL.</summary>
        [Newtonsoft.Json.JsonProperty("oAuthCListURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OAuthCListURL { get; set; }

        /// <summary>Collaboration OAuth client URL.</summary>
        [Newtonsoft.Json.JsonProperty("oAuthClientURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OAuthClientURL { get; set; }

        /// <summary>Collaboration REST URL.</summary>
        [Newtonsoft.Json.JsonProperty("restURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RestURL { get; set; }

        /// <summary>Collaboration Service URL.</summary>
        [Newtonsoft.Json.JsonProperty("serviceURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceURL { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static CollaborationConfigurationResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CollaborationConfigurationResponse>(data);
        }

    }

    /// <summary>Content Delivery Network configuration description.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class ContentDeliveryNetworkResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Content Delivery Network's URL.</summary>
        [Newtonsoft.Json.JsonProperty("domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain { get; set; }

        /// <summary>The description of the Content Delivery Network.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ContentDeliveryNetworkResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ContentDeliveryNetworkResponse>(data);
        }

    }

    /// <summary>Get email notification configuration response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class GetNotificationEmailResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Returns <code>true</code> if email notification is disabled. Returns <code>false</code> otherwise.</summary>
        [Newtonsoft.Json.JsonProperty("disableEmailNotifications", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisableEmailNotifications { get; set; }

        /// <summary>Item type <code>config</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static GetNotificationEmailResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GetNotificationEmailResponse>(data);
        }

    }

    /// <summary>Set email notification configuration request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SetNotificationEmailRequest
    {
        /// <summary>Set to <code>true</code> if email notification needs to be disabled. Set to <code>false</code> otherwise.</summary>
        [Newtonsoft.Json.JsonProperty("disableEmailNotifications", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisableEmailNotifications { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SetNotificationEmailRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SetNotificationEmailRequest>(data);
        }

    }

    /// <summary>Set email notification configuration response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SetNotificationEmailResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Item type <code>config</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SetNotificationEmailResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SetNotificationEmailResponse>(data);
        }

    }

    /// <summary>Folder metadata information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderDefinition
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>Folder name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Folder description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Size of the folder in bytes, including all of the files and folders contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>Number of items contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childitemsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChilditemsCount { get; set; }

        /// <summary>Date the folder was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the folder was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDefinition>(data);
        }

    }

    /// <summary>Folder metadata information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderDefinitionWithConversation
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>Folder name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Folder description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Size of the folder in bytes, including all of the files and folders contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>Number of items contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childitemsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChilditemsCount { get; set; }

        /// <summary>Date the folder was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the folder was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        /// <summary>Conversation ID associated with this folder or a parent folder.</summary>
        [Newtonsoft.Json.JsonProperty("conversationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationID { get; set; }

        /// <summary>Flag indicating whether the conversation ID is associated with the current folder (false) or if the conversation ID is associated with a parent folder (true).</summary>
        [Newtonsoft.Json.JsonProperty("isConversationInherited", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsConversationInherited { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderDefinitionWithConversation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDefinitionWithConversation>(data);
        }

    }

    /// <summary>The response body includes information about the folder.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderResponse : FolderDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderResponse>(data);
        }

    }

    /// <summary>The response body includes information about the folder.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderResponseWithConversation : FolderDefinitionWithConversation
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderResponseWithConversation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderResponseWithConversation>(data);
        }

    }

    /// <summary>The request body defines details of the create folder request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCreateBody
    {
        /// <summary>(Required) Specify the name of the newly created folder.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>(Optional) Specify a description for the newly created folder.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCreateBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCreateBody>(data);
        }

    }

    /// <summary>The request body defines details of the edit folder request. There are no required attributes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderEditBody
    {
        /// <summary>(Optional) Specify the name to assign to the folder.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>(Optional) Specify a description for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderEditBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderEditBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderDeleteResponse
    {
        /// <summary>Globally unique identifier (GUID) of the deleted folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderDeleteResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDeleteResponse>(data);
        }

    }

    /// <summary>The request body defines details of the copy folder request. <b>Bold</b> indicates a required value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCopyBody
    {
        /// <summary>(Required) Specify the globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationID { get; set; }

        /// <summary>(Optional) Specify the TimeStampSuffix option. The name of the copied folder is given a 6-digit suffix from the system timestamp.</summary>
        [Newtonsoft.Json.JsonProperty("duplicateResolution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicateResolution { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCopyBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCopyBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCopyResponse
    {
        /// <summary>Globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationID { get; set; }

        /// <summary>Globally unique identifier (GUID) of the newly created folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCopyResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCopyResponse>(data);
        }

    }

    /// <summary><p>The request body defines details of the move folder request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderMoveBody
    {
        /// <summary>(Required) Specify the globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationID { get; set; }

        /// <summary>(Optional) Specify the TimeStampSuffix option. The name of the moved folder is given a 6-digit suffix from the system timestamp.</summary>
        [Newtonsoft.Json.JsonProperty("duplicateResolution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicateResolution { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderMoveBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderMoveBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderMoveResponse
    {
        /// <summary>Globally unique identifier (GUID) of the destination folder.</summary>
        [Newtonsoft.Json.JsonProperty("destinationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationID { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderMoveResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderMoveResponse>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class HomeFolderContents
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>Total number of items in the response.</summary>
        [Newtonsoft.Json.JsonProperty("totalResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalResults { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the folder. If the referenced folder is the user&#39;s home folder, the value is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("ownerFolderID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OwnerFolderID { get; set; }

        /// <summary>The number of users found.</summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HasMore { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The files and subfolders in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileAndSubFoldersItemsDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static HomeFolderContents FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HomeFolderContents>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SpecificFolderContents
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>Total number of items in the response.</summary>
        [Newtonsoft.Json.JsonProperty("totalResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalResults { get; set; }

        /// <summary>The number of users found.</summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HasMore { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent  folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>Folder name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Folder description.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Size of the folder in bytes, including all of the files and folders contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>Number of items contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childitemsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChilditemsCount { get; set; }

        /// <summary>Date the folder was created.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Date the folder was last modified.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        /// <summary>The files and subfolders in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileAndSubFoldersItemsDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SpecificFolderContents FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SpecificFolderContents>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SearchFolderContents
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The point at which to begin the list of items or page of results from the complete set.</summary>
        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Offset { get; set; }

        /// <summary>Total number of items in the search.</summary>
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalCount { get; set; }

        /// <summary>The folders and files returned by the search.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileAndSubFoldersItemsDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SearchFolderContents FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SearchFolderContents>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class SearchSpecificFolderContents
    {
        /// <summary>The number of items listed on the page.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The point at which to begin the list of items or page of results from the complete set.</summary>
        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Offset { get; set; }

        /// <summary>Total number of items in the search.</summary>
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalCount { get; set; }

        /// <summary>The files and subfolders in the folder hierarchy.</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileAndSubFoldersItemsDefinition> Items { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SearchSpecificFolderContents FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SearchSpecificFolderContents>(data);
        }

    }

    /// <summary>The response body includes information about folder tags.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderGetTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) for the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Tags associated with this folder.</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tags { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderGetTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetTagsResponse>(data);
        }

    }

    /// <summary>The request body defines details of the set tags values request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderSetTagsBody
    {
        /// <summary>Comma-separated list of tags to be set to this folder.</summary>
        [Newtonsoft.Json.JsonProperty("setTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SetTags { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderSetTagsBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderSetTagsBody>(data);
        }

    }

    /// <summary>The response body includes information about folder tags set.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderSetTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderSetTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderSetTagsResponse>(data);
        }

    }

    /// <summary>The request body defines details of the edit tags values request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderEditTagsBody
    {
        /// <summary>Comma-separated list of tags to be added to this folder.</summary>
        [Newtonsoft.Json.JsonProperty("addTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AddTags { get; set; }

        /// <summary>Comma-separated list of tags to be removed from this folder.</summary>
        [Newtonsoft.Json.JsonProperty("removeTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoveTags { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderEditTagsBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderEditTagsBody>(data);
        }

    }

    /// <summary>The response body includes information about folder edit tags results.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderEditTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderEditTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderEditTagsResponse>(data);
        }

    }

    /// <summary>The response body includes information about folder delete tags results.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderDeleteTagsResponse
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderDeleteTagsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDeleteTagsResponse>(data);
        }

    }

    /// <summary>The response body includes information about the assign collection to a folder operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCollectionResponse>(data);
        }

    }

    /// <summary>The response body includes information about the get collection values operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderGetCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Collections Metadata { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderGetCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetCollectionResponse>(data);
        }

    }

    /// <summary>The response body includes information about the get assigned collections operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderGetAssignedCollectionResponse
    {
        /// <summary>Globally unique identifier (GUID) of the original folder.</summary>
        [Newtonsoft.Json.JsonProperty("idList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdList { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CollectionDefinition> MetadataFields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderGetAssignedCollectionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderGetAssignedCollectionResponse>(data);
        }

    }

    /// <summary><p>The request body defines details of the delete values in a folder metadata collection request. <b>Bold</b> indicates a required value.</p></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderDeleteValuesBody
    {
        /// <summary>Collection name. For a user personal collection, it must start with <code>Personal.</code>, such as <code>Personal.MyCollection</code>.</summary>
        [Newtonsoft.Json.JsonProperty("collection", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collection { get; set; }

        /// <summary>One or more field names, separated by commas, whose values you want to delete.</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Fields { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderDeleteValuesBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderDeleteValuesBody>(data);
        }

    }

    /// <summary>The request body defines details of the create folder conversation request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCreateConversationBody
    {
        /// <summary>Specify the name of the newly created folder conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string ConversationName { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCreateConversationBody FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCreateConversationBody>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderCreateConversationResponse
    {
        /// <summary>Globally unique identifier (GUID) for the folder.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Item type <code>folder</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>Globally unique identifier (GUID) of the newly created conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationID { get; set; }

        /// <summary>Conversation name.</summary>
        [Newtonsoft.Json.JsonProperty("conversationName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationName { get; set; }

        /// <summary>Applink for the conversation.</summary>
        [Newtonsoft.Json.JsonProperty("conversationAppLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationAppLink { get; set; }

        /// <summary>Access token that is valid for this applink for a limited duration.</summary>
        [Newtonsoft.Json.JsonProperty("conversationAppLinkToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConversationAppLinkToken { get; set; }

        /// <summary>List of inactive users.</summary>
        [Newtonsoft.Json.JsonProperty("listOfRemovedInactiveUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListOfRemovedInactiveUsers { get; set; }

        /// <summary>List of unknown users.</summary>
        [Newtonsoft.Json.JsonProperty("listOfUnknownUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListOfUnknownUsers { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderCreateConversationResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderCreateConversationResponse>(data);
        }

    }

    /// <summary>The response body includes information about the folder.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FolderListResponseWithConversation : FolderDefinition
    {
        /// <summary>An error code of zero (0) indicates no errors.</summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        /// <summary>The number of files in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childFileCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ChildFileCount { get; set; }

        /// <summary>The number of folders in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childFolderCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ChildFolderCount { get; set; }

        /// <summary>The total number of files and folders in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childItemsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ChildItemsCount { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FolderListResponseWithConversation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FolderListResponseWithConversation>(data);
        }

    }

    /// <summary>The files and subfolders in the folder.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public partial class FileAndSubFoldersItemsDefinition
    {
        /// <summary>Item type, either <code>folder</code> or <code>file</code>.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Globally unique identifier (GUID) for the folder or file.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary><p>Globally unique identifier (GUID) for the parent folder. If the parent  folder is the user&#39;s home folder, the value for <code>parentID</code> is <code>self</code>.</p></summary>
        [Newtonsoft.Json.JsonProperty("parentID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentID { get; set; }

        /// <summary>Folder or file name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("ownedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User OwnedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User ModifiedBy { get; set; }

        /// <summary>Folder or file creation date.</summary>
        [Newtonsoft.Json.JsonProperty("createdTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedTime { get; set; }

        /// <summary>Folder or file last modified date.</summary>
        [Newtonsoft.Json.JsonProperty("modifiedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ModifiedTime { get; set; }

        /// <summary><p>If the item is a file, the size of the file in bytes. If the item is a folder, then the size of the folder including all of the files and sub folders contained in the folder.</p></summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Size { get; set; }

        /// <summary>Number of items contained in the folder.</summary>
        [Newtonsoft.Json.JsonProperty("childItemsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChildItemsCount { get; set; }

        /// <summary>If the item is a file, the number of versions of the file.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FileAndSubFoldersItemsDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FileAndSubFoldersItemsDefinition>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum ShareDefinitionRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum ShareFolderBodyRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"manager")]
        Manager = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum ShareFolderEditRoleBodyRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"manager")]
        Manager = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum ApplinkBodyRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"manager")]
        Manager = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum PublicLinkDefinitionRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum PublicLinkBodyRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.11.0 (Newtonsoft.Json v10.0.0.0)")]
    public enum PublicLinkEditBodyRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"viewer")]
        Viewer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downloader")]
        Downloader = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"contributor")]
        Contributor = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.0.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
        {
            Data = data;
            FileName = fileName;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }
    }

    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.0.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.0.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

    #pragma warning restore
}